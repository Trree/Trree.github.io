<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tree</title>
  <subtitle>追寻一切未知</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="%5Bobject%20Object%5D/"/>
  <updated>2017-07-27T12:10:20.000Z</updated>
  <id>[object Object]/</id>
  
  <author>
    <name>Feilong</name>
    <email>wufeilongsky@gmail.com,wufeilongncu@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>openvpn简述</title>
    <link href="%5Bobject%20Object%5D/2017/07/27/openvpn/"/>
    <id>[object Object]/2017/07/27/openvpn/</id>
    <published>2017-07-27T12:06:27.000Z</published>
    <updated>2017-07-27T12:10:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>TCP/IP网络，IP路由</p>
<h2 id="VPN与OpenVPN"><a href="#VPN与OpenVPN" class="headerlink" title="VPN与OpenVPN"></a>VPN与OpenVPN</h2><p>VPN是一种实现虚拟专用网的技术。 典型的实现有IPSec，L2TP，PPTP等，各类OS都有相应的支持，开源的轻量级实现有OpenVPN。</p>
<h2 id="OpenVPN"><a href="#OpenVPN" class="headerlink" title="OpenVPN"></a>OpenVPN</h2><p>OpenVPN实现了一个灵活的VPN，和通过修改协议栈而实现的基于IPSec的VPN相比，OpenVPN有以下的优点：</p>
<ul>
<li>OpenVPN无需对协议栈进行任何修改，无需专门的策略来解决VPN数据穿越NAT的问题，因此可在现有的网络进行规划；</li>
<li>OpenVPN使用虚拟网卡和路由进行虚拟网络的构建，配置十分方便；</li>
<li>OpenVPN使用SSL协议对虚拟网络提供保护，从而实现“专用”，而SSL提供了丰富灵活的安全特性；</li>
<li>OpenVPN的push模式可以最大限度简化客户端配置，服务器和客户端可以不必花费太多的精力来使得两端一致。</li>
<li>OpenVPN实际上是虚拟网卡设备，TCP/IP网络技术，路由技术，SSL结合而成的一个应用，前三者构建了虚拟网络—隧道连接的网络，最后的SSL保证了虚拟网络通信的安全——隧道通信的认证和加密，因此使用OpenVPN的过程基本就是对上述四方面进行配置的过程。</li>
</ul>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><!--![](./SSL5_VPN_Connect.png)-->
<h2 id="OpenVPN-协议"><a href="#OpenVPN-协议" class="headerlink" title="OpenVPN 协议"></a>OpenVPN 协议</h2><!--![](./openvpn_protocol.jpg)-->
<h3 id="OpenVPN连接建立"><a href="#OpenVPN连接建立" class="headerlink" title="OpenVPN连接建立"></a>OpenVPN连接建立</h3><!--![](openvpn_sharkhand.jpg)-->
<p><a href="http://blog.csdn.net/dog250/article/details/6639470" target="_blank" rel="external"><a href="http://blog.csdn.net/dog250/article/details/6639470" target="_blank" rel="external">OpenVPN协议解析-网络结构之外</a></a></p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="虚拟网卡——OpenVPN最重要的概念"><a href="#虚拟网卡——OpenVPN最重要的概念" class="headerlink" title="虚拟网卡——OpenVPN最重要的概念"></a>虚拟网卡——OpenVPN最重要的概念</h3><p> <a href="https://www.ibm.com/developerworks/cn/linux/l-tuntap/" target="_blank" rel="external">虚拟网卡 TUN/TAP 驱动程序设计原理</a></p>
<p>虚拟网卡可以看作是一个连接协议栈底层和用户态应用程序的一个管道，数据从虚拟网卡流出，进入应用程序，封装后发出，如下图所示：</p>
<p><img src="./OpenVPN_Datagram.jpg" alt=""></p>
<h3 id="IP路由"><a href="#IP路由" class="headerlink" title="IP路由"></a>IP路由</h3><p>IP路由在OpenVPN中起着至关重要的作用，数据包之所以能被截获进而被加密，完全靠IP路由</p>
<h2 id="OpenVPN服务端配置实例"><a href="#OpenVPN服务端配置实例" class="headerlink" title="OpenVPN服务端配置实例"></a>OpenVPN服务端配置实例</h2><pre><code>#执行外部程序的安全等级
script-security 2
#虚拟网卡设备：tun封装三层IP数据报，tap封装二层以太帧，支持非IP协议
dev tap
#使用的封装协议：tcp与udp
proto udp
#SSL握手时的角色
tls-server
tls-cipher RC4-MD5
cipher BF-CBC
#心跳保活
keepalive 1 5
#模式：p2p-仅两端端点；server-一个server可以被多个client连接
mode server
#虚拟IP地址池
server 128.129.0.0 255.255.0.0
#本地侦听地址和端口
local 0.0.0.0
port 6119
#日志等级
verb 4
dh dh1024.pem.dh.conf
#配置证书链
ca sslvpn.cer
#配置用户证书
cert /kssl/RHVPNS/cfg/pem/cae0c1c4.dbcb1db54387be84651b8edbe753af7dc1b9e88a.pem
key  /kssl/RHVPNS/cfg/pem/cae0c1c4.dbcb1db54387be84651b8edbe753af7dc1b9e88a.key
</code></pre><h2 id="OpenVPN客户端配置实例"><a href="#OpenVPN客户端配置实例" class="headerlink" title="OpenVPN客户端配置实例"></a>OpenVPN客户端配置实例</h2><pre><code>script-security 2
dev tap
#定义自己的角色为客户端
client
proto udp
#自己断开时通知服务端，仅在udp协议下有效
explicit-exit-notify
#连接服务端的IP地址以及端口
remote 192.168.40.249  6119
#如果SSL握手不成功，便退出
tls-exit
resolv-retry infinite
#并不bind本地IP地址，由IP路由自动选择
nobind
#允许服务端地址漂移（高级）
float
verb 4
#配置证书链
ca /kssl/VPN/cfg/SSL-DemoCA.cer
#配置本地用户证书
pkcs12 psbc.pfx
</code></pre><h2 id="OpenVPN的事件"><a href="#OpenVPN的事件" class="headerlink" title="OpenVPN的事件"></a>OpenVPN的事件</h2><p>OpenVPN可以在发生某些重要事件时执行外部脚本，对于服务端，典型的事件有：</p>
<ul>
<li>虚拟网卡启动：只需要在服务端的配置文件中加入up /root/up.sh，即可，一个例子如下：</li>
</ul>
<pre><code>#!/bin/bash
route add 1.2.3.4 gw 128.129.0.2
</code></pre><ul>
<li>客户端连接：只需要在服务端配置文件中加入client-connect /root/conn.sh，即可，一个例子如下：</li>
</ul>
<pre><code>#!/bin/bash
echo  “push route 12.12.12.12 255.255.255.255&quot; &gt;&gt;$1
</code></pre><ul>
<li>客户端断开：某一个客户端断开的时候，会执行，一个例子如下：</li>
</ul>
<pre><code>#!/bin/bash
#有大量环境变量可用，可通过env来查询
name=$(printenv common_name)
real_addr=$(printenv trusted_ip)
echo $(date) &quot;client $name from $ real_addr disconnect&quot; &gt;&gt; /kssl/RHVPNS/log/conn.log
</code></pre><p>客户端典型的事件如下：</p>
<ul>
<li>up，down同服务端</li>
<li>服务端推送的路由生效时：在客户端配置中加入route-up “/kssl/VPNC/bin/route-add.sh” 即可</li>
</ul>
<p>在以上事件发生时，除了使用bash，python，php等脚本之外，还可以使用plugin，一个plugin就是一个so/dll，它初始化时注册感兴趣的事件，事件发生时调用其回调函数。</p>
<ul>
<li>OpenVPN简介</li>
</ul>
<p>VPN替代昂贵的专线用以在开放的Internet上实现了一个虚拟的网络，该虚拟网络本身在不安全的真实网络上对数据提供安全保护。</p>
<p>OpenVPN实现了一个灵活的VPN，和通过修改协议栈而实现的基于IPSec的VPN相比，OpenVPN有以下的优点：</p>
<ol>
<li>OpenVPN无需对协议栈进行任何修改，无需专门的策略来解决VPN数据穿越NAT的问题，因此可在现有的网络进行规划；</li>
<li>OpenVPN使用虚拟网卡和路由进行虚拟网络的构建，配置十分方便；</li>
<li>OpenVPN使用SSL协议对虚拟网络提供保护，从而实现“专用”，而SSL提供了丰富灵活的安全特性；</li>
<li>OpenVPN的push模式可以最大限度简化客户端配置，服务器和客户端可以不必花费太多的精力来使得两端一致。</li>
</ol>
<p>OpenVPN实际上是虚拟网卡设备，TCP/IP网络技术，路由技术，SSL结合而成的一个应用，前三者构建了虚拟网络—隧道连接的网络，最后SSL保证了虚拟网络通信的安全—隧道通信的认证和加密，因此使用OpenVPN的过程基本就是对上述四方面进行配置的过程。</p>
<h2 id="OpenVPN关键配置项"><a href="#OpenVPN关键配置项" class="headerlink" title="OpenVPN关键配置项"></a>OpenVPN关键配置项</h2><ul>
<li>–dev tunX|tapX：配置虚拟网络使用的网卡设备，X是一个数字表示网卡的编号，在Unix/Linux系统中，它是一个字符设备，在Windows中，它是一个设备命名空间中的一个节点，tun设备和tap设备的区别在于出入前者的第三层（IP）数据报，而出入后者的是第二层（以太网）数据帧。</li>
</ul>
<p>注意：tap设备是二层设备，tun设备为三层设备，此二者各有优劣，简述如下</p>
<ul>
<li>tap特点:</li>
</ul>
<ol>
<li>应用这种设备可以复用任意的三层数据报；</li>
<li>构成一个两路层网络，比如以太网，因此广播数据可以自由跨隧道传输；</li>
<li>无需路由即可进行节点通信；</li>
<li>配置简单，但是缺乏灵活性，IP层的优良特性无法自由应用。</li>
</ol>
<ul>
<li>tun特点:</li>
</ul>
<ol>
<li>可以应用IP层的所有特性，比如Routing，IP-Qos，IP-fragment/de等，但是只支持IP数据报；</li>
<li>构成三层网络，节点间如不在一个子网要路由；</li>
<li>三层虚拟网络的每个子网下面没有链路层承载（ip数据报直接导出），因此链路层特性无法应用，比如以太网广播无法跨隧道传输，因此此虚拟网络是无法指定网关的。</li>
</ol>
<ul>
<li>–dev-type dt：指示虚拟网卡设备的类型，仅仅在—dev参数无法识别设备类型的时候使用。</li>
<li>–dev-node node：任意节点node被指示为虚拟网卡设备，node的路径以及名称可以任意，但是如果不是tunX/tapX的形式，那么必须配置—dev-type参数。</li>
<li>–lladdr hw：为虚拟网卡配置链路层地址。</li>
</ul>
<h2 id="网络配置参数"><a href="#网络配置参数" class="headerlink" title="网络配置参数"></a>网络配置参数</h2><ul>
<li>–local host：配置本地使用的IP地址，如果不是为了bind，那么可以不配置此参数，OpenVPN会自行处理。</li>
<li>–remote host [port]：用于client端，配置client连接的server的IP或者主机名以及port，该参数可以配置多个用以实现一定的冗余，client则按照配置顺序依次连接server，直到连接成功为止。</li>
</ul>
<ul>
<li>–proto p：配置隧道的类型，可以是udp或者tcp，其中tcp必须指明是server还是client，而udp可以不区分server和client，因此p可以为udp，tcp-server，tcp-client。</li>
</ul>
<pre><code>注意：用tcp还是用udp构建隧道呢？默认是udp。任何有连接的协议在出现丢包时都会要求重发或者自动超时重发，为了避免因对网络带宽的未知或者网络拥塞而丢包从而导致端点重发，tcp实现了慢启动，滑动窗口以及加增承减等机制，不幸的是，以上机制仅可用于分层模型中的一层，在不同层次都实现得如此复杂就可能引起判断叠加从而使得上述机制无法做出最好的判断，比如用tcp建立的隧道，并且上面承载的又是tcp数据，那么一旦出现丢包，最终的端点以及隧道都要重发数据，这就导致了网络流量突然增大，后面的行为很难在短时间给出预测并采取措施。事实上如果隧道本身并不是非用tcp不可，那么最好使用udp，保证连接与否是最终终端的事，而不是隧道的事，如果说最终用户使用tcp，那么他自己就保证了连接，如果他使用udp，那么说明他不在乎是否有连接，因此隧道使用udp，相反隧道使用tcp建立的话，如果最终用户使用tcp已经保证了连接，隧道没必要再多此一举，如果最终用户使用udp，那么隧道的tcp就降低了用户连接的效率，抵消了他使用udp的结果。
</code></pre><ul>
<li>–connect-retry n：配置连接重试的次数，仅仅对于—proto参数为tcp-client时有效。</li>
<li>–connect-timeout n：连接重试的间隔。</li>
<li>–auto-proxy：</li>
<li>–bind：</li>
<li>–nobind：</li>
</ul>
<ul>
<li>–link-mtu n：配置四层链路的MTU，同时用同样的数值配置设备的MTU。</li>
</ul>
<pre><code>注意：这个配置可能会引起莫名其妙的问题，就其本质是由于OpenVPN不允许通过隧道的数据被任意分段，即使是IP分片也必须妥善处理，OpenVPN用一种规则的方式来收发socket数据。IP层将数据路由到虚拟网卡前如果发现数据报的长度大于虚拟网卡的MTU，那么就会将数据报分片，如果VPN两端的虚拟网卡的MTU设置不一致，OpenVPN接收socket数据的时候就会产生问题，因为最一般的情况下OpenVPN调用recv/recvfrom的时候，参数中的len总是设置成自己的link-mtu，假设两端H1和H2的link-mtu分别为L1 和L2（L1&gt;L2），H1端发送数据给H2，则数据在H2则会接收不完整，因此势必会产生错误，即使解密收到的数据可能正确，由于数据长度不一致，校验时也会出错，即使在没有校验的情形下，由OpenVPN发送给虚拟网卡的IP数据报也会不完整。因此最好不要配置link-mtu参数，让它默认值好了，如果非要配置，保持两端一致。可以在linux上用strace，tcpdump以及OpenVPN源代码确认以上问题，具体为何这样设计还不清楚。如果在不考虑安全因素（程序输出的意思是防止active attack）可以更合理一些的话，我觉得recv数据时要按照对方的mtu来接收，毕竟recv和send只是一个中间阶段，数据从对端虚拟网卡的字符设备出来后就被send了，然后在本端被recv，之后被write进本端的虚拟网卡字符设备，如果仅仅按照本端的mtu来接收，势必会有问题，就好像在物理层上将数据截断一样。（在隧道的一端ping另一端，如果mtu不一致并且ping包大于mtu的小者的话，一定不同，可是仅仅将两端作为中间隧道的话就不一定了，数据从主机A，经由隧道的起始Ts，到达隧道终点Te，最终到达主机B，如果Ts和Te的mtu中小者都比A和B的mtu的大者大，在不考虑复杂的分段情况下是可以通的）因此，一种“几乎总是正确”的配置方法就是将mtu配置成一个很大的值，要比已知的物理链路的mtu都大，这样一来不会出错，二来可以不必担心两端不一致，三来可以最大限度的发送数据，而不会因为隧道太窄的缘故而降低数据发送速率，如果不理解以上这些或者为了保险起见，还是将mtu留默认比较好。
</code></pre><ul>
<li>–tun-mtu：注意事项同上，但是要强调和link-mtu之不同，此二者配置一个即可且只能配置一个，此中之缘由在于其关联性，tun-mtu为虚拟网卡之mtu，而link-mtu则为链路的mtu，其大小相差一个固定长度，二者区别等同于TCP的MSS和物理链路的MTU之区别。</li>
<li>–shaper：该参数对隧道的带宽进行了限制，主要用于建立多个通道时在各个通道进行策略化带宽分配，如果只建立一个通道，也就是说仅仅运行一个OpenVPN实例的话，这个参数就目前版本而言意义不大，因为本身单进程单线程的OpenVPN速度就很慢，再限速更没有意义了。</li>
<li>–txqueuelen：该参数设定虚拟网卡的最大排队包的数量，也就是队列长度，默认为100，对于OpenVPN这样很慢的VPN来说，100就够了，即使你设得再大，用户空间的OpenVPN进程处理不过来还是白搭。</li>
</ul>
<h2 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h2><ul>
<li>–route network [netmask] [gateway] [metric]：增加一条路由。</li>
<li>–max-routes n：</li>
<li>–route-gateway gw|’dhcp’：</li>
<li>–route-metric m：配置路由的传输开销</li>
</ul>
<ul>
<li>–route-delay n [w]：配置路由添加的延迟，这是为了解决一IP地址自动配置的问题，有时候OpenVPN要添加路由了，可是OS还没有准备好，所以要给与一定的延迟。具体来说就是，client和server的连接建立以后，server需要往client端push一些信息，包括虚拟网卡ip地址，子网掩码等必须的信息以及路由等可选信息，client接收到以后需要在本机做相应的配置，比如配置虚拟网卡的ip/子网掩码，添加路由等，并且OpenVPN对虚拟网卡的管理采取了一种懒惰的方式，也就是对于server只有在OpenVPN起来，对于client只有在和server的连接建立的时候才会建立虚拟网卡对象并初始化，这个初始化过程就包括了设置ip地址/子网掩码，这个过程完成之前，添加路由是失败的，因此必须提供一些延迟保证虚拟网卡初始化完毕之后再添加路由。这个选项主要针对某些虚拟网卡驱动设计不友好的系统，比如基于NDIS驱动的windows系统，虚拟网卡的ip地址“看起来”是通过DHCP来分配，而DHCP分配是需要花费时间的，此间添加路由的请求必须等待。</li>
</ul>
<h2 id="SSL及安全参数"><a href="#SSL及安全参数" class="headerlink" title="SSL及安全参数"></a>SSL及安全参数</h2><ul>
<li>–genkey：生成一个对称密钥，该参数只能单独使用，该对称密钥的生成是为了使OpenVPN两端共享，从而不再使用SSL握手协议进行密钥协商。</li>
</ul>
<ul>
<li>–secret file：使用共享的对称密钥。这实际上省去了SSL的握手，用于通信双方确信已拥有绝对保密绝对安全的对称密钥的情况，实际上SSL的握手也是为了这个保证，二者殊途同归，因此问题的难度就在于一端用—genkey生成的密钥如何传输至另一端。这其实就是另一个大问题了，可以用数字信封传过去，甚至可以冒险用明文直接发过去，这些都不是OpenVPN要考虑的。一般地在都是通过scp程序传递的，方便又安全。</li>
</ul>
<ul>
<li>–reneg-XXX：这一族参数用来重新协商session key。OpenVPN基于SSL协议，然则其用法另有说法，SSL协议自带认证和加密功能，对于OpenVPN来说此二者是分开的，如果不考虑认证，密钥协商的过程很容易受到中间人攻击，因此不管是基于IPSec这种修改或挂钩协议栈实现的VPN还是OpenVPN都提供了认证机制。OpenVPN使用证书来进行认证，使用DH来进行密钥协商。使用DH而不是别的是由于建立的隧道安全参数要每隔一段时间进行一次重新协商，默认时间为1个小时，而DH的效率很高，它不像RSA产生密钥那么耗时（由于美国出限制或者证书中没有可用于加密的公钥，在SSL握手时就需要临时生成一对RSA密钥），如此在server key exchange message消息中传输的就是DH参数了。</li>
</ul>
<ul>
<li>–ca file：CA证书，用以验证对端的用户证书，这个参数可以包含多个证书，也就是一条证书链，在Unix/Linux中可以用cat命令将多个证书追加成一个文件。</li>
<li>–cert file：自己的证书，用于传递给对端以表明自己的身份或者实现其它的准入性验证。</li>
<li>–key file：对应—cert参数的key文件。</li>
</ul>
<ul>
<li>–cryptoapicert select-string：用于从Windows的证书Store中获取证书，如此就不再需要—cert和—key参数了，select-string是一个字符串，可以认为是一个查找“键值”，以”名称:值”的形式存在，比如使用颁发给名字是“老李”的个人的证书，那么select-string就是：”SUBJ:老李”。这个参数多数用于key或者证书无法单独导出的环境下，比如一些设备。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wiki.koal.com/wiki/index.php/网络知识培训：OpenVPN的使用和配置" target="_blank" rel="external">OpenVPN的使用和配置</a></p>
<p><a href="https://openvpn.net/index.php/open-source/documentation/manuals/65-openvpn-20x-manpage.html" target="_blank" rel="external">openvpn</a></p>
<p><a href="http://blog.csdn.net/dog250/article/list/1" target="_blank" rel="external">blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;p&gt;TCP/IP网络，IP路由&lt;/p&gt;
&lt;h2 id=&quot;VPN与OpenVPN&quot;&gt;&lt;a href=&quot;#VPN与OpenVPN&quot; 
    
    </summary>
    
    
      <category term="Tech" scheme="%5Bobject%20Object%5D/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>Apache 讲解</title>
    <link href="%5Bobject%20Object%5D/2017/07/09/apapche-pratice/"/>
    <id>[object Object]/2017/07/09/apapche-pratice/</id>
    <published>2017-07-09T03:26:10.000Z</published>
    <updated>2017-07-16T07:13:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="简单服务器流程"><a href="#简单服务器流程" class="headerlink" title="简单服务器流程"></a>简单服务器流程</h3><p>Q1：<a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/" target="_blank" rel="external">简述在浏览器中输入 www.baidu.com 之后发生的一系列事情</a></p>

<p>appendix1：<a href="https://stackoverflow.com/questions/246859/http-1-0-vs-1-1" target="_blank" rel="external">http1.0 vs http1.1</a></p>
<h3 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h3><ul>
<li>阻塞式 I/O 模型  </li>
<li>非阻塞 I/O 模型  </li>
<li>I/O 复用 模型    </li>
<li>异步 I/O 模型    </li>
</ul>
<p><a href="http://download.csdn.net/download/xumaojun/4680440" target="_blank" rel="external"><em>UNIX网络编程</em>(卷1)：套接字联网API(第3版)</a></p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><ul>
<li><a href="https://httpd.apache.org/docs/2.4/mod/event.html" target="_blank" rel="external">event</a>(多进程多线程)</li>
</ul>
<ul>
<li><a href="https://httpd.apache.org/docs/2.4/mod/prefork.html" target="_blank" rel="external">prefork</a>(多进程)</li>
</ul>
<ul>
<li><a href="https://httpd.apache.org/docs/2.4/mod/worker.html" target="_blank" rel="external">worker</a>(多进程多线程)</li>
</ul>
<p><strong>查看apache的工作模式</strong></p>
<blockquote>
<p>/usr/sbin/apachectl -V</p>
</blockquote>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><a href="https://trree.github.io/2017/02/06/apache-pool/" target="_blank" rel="external">内存管理</a></p>
<h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3>
<p><strong>request的关键元素</strong></p>
<p>The most essential part of any request is the <strong>request record</strong>. In a call to a handler function, this is represented by the <strong>request_rec</strong> structure passed along with every call that is made. This struct, typically just referred to as <code>r</code> in modules, contains all the information you need for your module to fully process any HTTP request and respond accordingly.</p>
<p>Some key elements of the <code>request_rec</code>structure are:</p>
<ul>
<li><code>r-&gt;handler (char*):</code> Contains the name of the handler the server is currently asking to do the handling of this request</li>
<li><code>r-&gt;method (char*):</code> Contains the HTTP method being used, f.x. GET or POST</li>
<li><code>r-&gt;filename (char*):</code> Contains the translated filename the client is requesting</li>
<li><code>r-&gt;args (char*):</code> Contains the query string of the request, if any</li>
<li><code>r-&gt;headers_in (apr_table_t*):</code> Contains all the headers sent by the client</li>
<li><code>r-&gt;connection (conn_rec*):</code> A record containing information about the current connection</li>
<li><code>r-&gt;user (char*):</code> If the URI requires authentication, this is set to the username provided</li>
<li><code>r-&gt;useragent_ip (char*):</code> The IP address of the client connecting to us</li>
<li><code>r-&gt;pool (apr_pool_t*)</code>: The memory pool of this request. We’ll discuss this in the “<a href="https://httpd.apache.org/docs/2.4/en/developer/#memory" target="_blank" rel="external">Memory management</a>“ chapter.</li>
</ul>
<p><a href="http://wiki.koal.com/wiki/index.php/Apache:%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="external">核心数据结构</a></p>
<h3 id="mod-helloworld-模块讲解"><a href="#mod-helloworld-模块讲解" class="headerlink" title="mod_helloworld 模块讲解"></a>mod_helloworld 模块讲解</h3><p><a href="https://httpd.apache.org/docs/2.4/en/developer/modguide.html" target="_blank" rel="external">modguide</a></p>
<p><a href="http://wiki.koal.com/wiki/index.php/Apache:%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B" target="_blank" rel="external">Apache: 启动流程</a></p>
<p><a href="http://wiki.koal.com/wiki/index.php/Apache:%E8%BF%9E%E6%8E%A5/%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B" target="_blank" rel="external">Apache: 连接 / 请求处理流程</a></p>
<blockquote>
<p>apxs -n helloworld -g</p>
</blockquote>
<p><strong>Defining a module</strong></p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"httpd.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"http_config.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"http_protocol.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"ap_config.h"</span></span>

<span class="token comment" spellcheck="true">/* The sample content handler */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">helloworld_handler</span><span class="token punctuation">(</span>request_rec <span class="token operator">*</span>r<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>r<span class="token operator">-></span>handler<span class="token punctuation">,</span> <span class="token string">"helloworld"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> DECLINED<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    r<span class="token operator">-></span>content_type <span class="token operator">=</span> <span class="token string">"text/html"</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>r<span class="token operator">-></span>header_only<span class="token punctuation">)</span>
        <span class="token function">ap_rputs</span><span class="token punctuation">(</span><span class="token string">"The sample page from mod_helloworld.c\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">helloworld_register_hooks</span><span class="token punctuation">(</span>apr_pool_t <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">ap_hook_handler</span><span class="token punctuation">(</span>helloworld_handler<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> APR_HOOK_MIDDLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/* Dispatch list for API hooks */</span>
<span class="token comment" spellcheck="true">/* 标记服务器能够加载的模块名 */</span>
<span class="token comment" spellcheck="true">/* 为模块配置设置一个命名空间 */</span>
module AP_MODULE_DECLARE_DATA helloworld_module <span class="token operator">=</span> <span class="token punctuation">{</span>
    STANDARD20_MODULE_STUFF<span class="token punctuation">,</span>
    <span class="token constant">NULL</span><span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">/* create per-dir    config structures */</span>
    <span class="token constant">NULL</span><span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">/* merge  per-dir    config structures */</span>
    <span class="token constant">NULL</span><span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">/* create per-server config structures */</span>
    <span class="token constant">NULL</span><span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">/* merge  per-server config structures */</span>
    helloworld_directives<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* table of config file commands       */</span>
    helloworld_register_hooks  <span class="token comment" spellcheck="true">/* register hooks                      */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span>         enabled<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* Enable or disable our module */</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* Some path to...something */</span>
    <span class="token keyword">int</span>         typeOfAction<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 1 means action A, 2 means action B and so on */</span>
<span class="token punctuation">}</span> example_config<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> command_rec helloworld_directives<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>
<span class="token punctuation">{</span>
    <span class="token function">AP_INIT_TAKE1</span><span class="token punctuation">(</span><span class="token string">"exampleEnabled"</span><span class="token punctuation">,</span> example_set_enabled<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> RSRC_CONF<span class="token punctuation">,</span> <span class="token string">"Enable or disable mod_example"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">AP_INIT_TAKE1</span><span class="token punctuation">(</span><span class="token string">"examplePath"</span><span class="token punctuation">,</span> example_set_path<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> RSRC_CONF<span class="token punctuation">,</span> <span class="token string">"The path to whatever"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">AP_INIT_TAKE2</span><span class="token punctuation">(</span><span class="token string">"exampleAction"</span><span class="token punctuation">,</span> example_set_action<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> RSRC_CONF<span class="token punctuation">,</span> <span class="token string">"Special action value!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>

<h4 id="配置的作用域"><a href="#配置的作用域" class="headerlink" title="配置的作用域"></a>配置的作用域</h4><ul>
<li>OR_ALL 所有的地方使用</li>
<li>ACCESS_CONF：允许指令出现这Directiory Location 区间<strong>以内</strong>的顶级命令区，一般是用来设置特定文的指令控制</li>
<li>RSRC_CONF: 允许指令出现在 Directiory Location 区间<strong>以外</strong>的顶级命令区</li>
</ul>
<h4 id="配置段合并"><a href="#配置段合并" class="headerlink" title="配置段合并"></a>配置段合并</h4><p>配置段会按非常特别的顺序依次生效，由于这会对配置指令的处理结果产生重大影响，因此理解它的流程非常重要。</p>
<p>合并的顺序是：</p>
<ol>
<li><code>&lt;Directory&gt;</code>(除了正则表达式)和<code>.htaccess</code>同时处理；(如果允许的话，<code>.htaccess</code>的设置会覆盖<code>&lt;Directory&gt;</code>的设置)</li>
<li><code>&lt;DirectoryMatch&gt;</code>(和<code>&lt;Directory ~&gt;</code>)</li>
<li><code>&lt;Files&gt;</code>和<code>&lt;FilesMatch&gt;</code>同时处理</li>
<li><code>&lt;Location&gt;</code>和<code>&lt;LocationMatch&gt;</code>同时处理</li>
</ol>
<p>除了<code>&lt;Directory&gt;</code>，每个组都按它们在配置文件中出现的顺序被依次处理，而<code>&lt;Directory&gt;</code>(上面的第1组)，会按字典顺序由短到长被依次处理。例如：<code>&lt;Directory /var/web/dir&gt;</code>会先于<code>&lt;Directory /var/web/dir/subdir&gt;</code>被处理。如果有多个指向同一个目录的<code>&lt;Directory&gt;</code>段，则按它们在配置文件中的顺序被依次处理。用<code>Include</code>指令包含进来的配置被视为按原样插入到<code>Include</code>指令的位置。</p>
<p>位于<code>&lt;VirtualHost&gt;</code>容器中的配置段在外部对应的段处理完毕<em>以后</em>再处理，这样就允许虚拟主机覆盖主服务器的设置。</p>
<p><strong>代码示例</strong></p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">create_dir_conf</span><span class="token punctuation">(</span>apr_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    context <span class="token operator">=</span> context <span class="token operator">?</span> context <span class="token punctuation">:</span> <span class="token string">"(undefined context)"</span><span class="token punctuation">;</span>
    example_config <span class="token operator">*</span>cfg <span class="token operator">=</span> <span class="token function">apr_pcalloc</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>example_config<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>cfg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/* Set some default values */</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>cfg<span class="token operator">-></span>context<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cfg<span class="token operator">-></span>enabled <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        cfg<span class="token operator">-></span>path <span class="token operator">=</span> <span class="token string">"/foo/bar"</span><span class="token punctuation">;</span>
        cfg<span class="token operator">-></span>typeOfAction <span class="token operator">=</span> <span class="token number">0x11</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> cfg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">merge_dir_conf</span><span class="token punctuation">(</span>apr_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>BASE<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>ADD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    example_config <span class="token operator">*</span>base <span class="token operator">=</span> <span class="token punctuation">(</span>example_config <span class="token operator">*</span><span class="token punctuation">)</span> BASE <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* This is what was set in the parent context */</span>
    example_config <span class="token operator">*</span>add <span class="token operator">=</span> <span class="token punctuation">(</span>example_config <span class="token operator">*</span><span class="token punctuation">)</span> ADD <span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* This is what is set in the new context */</span>
    example_config <span class="token operator">*</span>conf <span class="token operator">=</span> <span class="token punctuation">(</span>example_config <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">create_dir_conf</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> <span class="token string">"Merged configuration"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* This will be the merged configuration */</span>

    <span class="token comment" spellcheck="true">/* Merge configurations */</span>
    conf<span class="token operator">-></span>enabled <span class="token operator">=</span> <span class="token punctuation">(</span> add<span class="token operator">-></span>enabled <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token operator">?</span> base<span class="token operator">-></span>enabled <span class="token punctuation">:</span> add<span class="token operator">-></span>enabled <span class="token punctuation">;</span>
    conf<span class="token operator">-></span>typeOfAction <span class="token operator">=</span> add<span class="token operator">-></span>typeOfAction <span class="token operator">?</span> add<span class="token operator">-></span>typeOfAction <span class="token punctuation">:</span> base<span class="token operator">-></span>typeOfAction<span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>conf<span class="token operator">-></span>path<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>add<span class="token operator">-></span>path<span class="token punctuation">)</span> <span class="token operator">?</span> add<span class="token operator">-></span>path <span class="token punctuation">:</span> base<span class="token operator">-></span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> conf <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

module AP_MODULE_DECLARE_DATA   example_module <span class="token operator">=</span>
<span class="token punctuation">{</span>
    STANDARD20_MODULE_STUFF<span class="token punctuation">,</span>
    create_dir_conf<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* Per-directory configuration handler */</span>
    merge_dir_conf<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/* Merge handler for per-directory configurations */</span>
    <span class="token constant">NULL</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">/* Per-server configuration handler */</span>
    <span class="token constant">NULL</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">/* Merge handler for per-server configurations */</span>
    directives<span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">/* Any directives we may have for httpd */</span>
    register_hooks   <span class="token comment" spellcheck="true">/* Our hook registering function */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="hook-钩子"><a href="#hook-钩子" class="headerlink" title="hook 钩子"></a>hook 钩子</h3>
<p><strong>钩子的处理</strong></p>
<ul>
<li><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*在这个钩子处按照顺序运行所有的被注册函数*/</span>
<span class="token function">AP_IMPLEMENT_HOOK_VOID</span><span class="token punctuation">(</span>do_something<span class="token punctuation">,</span> <span class="token punctuation">(</span>request_rec <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>r<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</li>
</ul>
<ul>
<li><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*在这个钩子处运行所有的被注册函数直到返回了一个不是DECLINED的值*/</span>
<span class="token function">AP_IMPLEMENT_HOOK_RUN_FIRST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> do_something<span class="token punctuation">,</span> <span class="token punctuation">(</span>request_rec <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>r<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> DECLINED<span class="token punctuation">)</span>
</code></pre>
</li>
<li><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*运行所有的函数直到或者除非返回一个错误*/</span>
<span class="token function">AP_IMPLEMENT_HOOK_RUN_ALL</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> do_something<span class="token punctuation">,</span> <span class="token punctuation">(</span>request_rec <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>r<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> OK<span class="token punctuation">,</span> DECLINED<span class="token punctuation">)</span>
</code></pre>
</li>
</ul>
<p><strong>其它有用的钩子</strong></p>
<p>Hooking into the request handling phase is but one of many hooks that you can create. Some other ways of hooking are:</p>
<ul>
<li><p><code>ap_hook_child_init</code>: Place a hook that executes when a child process is spawned (commonly used for initializing modules after the server has forked)</p>
</li>
<li><p><code>ap_hook_pre_config</code>: Place a hook that executes before any configuration data has been read (very early hook)</p>
</li>
<li><p><code>ap_hook_post_config</code>: Place a hook that executes after configuration has been parsed, but before the server has forked</p>
</li>
<li><p><code>ap_hook_translate_name</code>: Place a hook that executes when a URI needs to be translated into a filename on the server (think <code>mod_rewrite</code>)</p>
</li>
<li><p><code>ap_hook_quick_handler</code>: Similar to <code>ap_hook_handler</code>, except it is run before any other request hooks (translation, auth, fixups etc)</p>
</li>
<li><p><code>ap_hook_log_transaction</code>: Place a hook that executes when the server is about to add a log entry of the current request</p>
<p>​</p>
</li>
</ul>
<h3 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h3><p><a href="https://trree.github.io/2017/03/22/apache-debug/" target="_blank" rel="external">apache调试</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;简单服务器流程&quot;&gt;&lt;a href=&quot;#简单服务器流程&quot; class=&quot;headerlink&quot; title=&quot;简单服务器流程&quot;&gt;&lt;/
    
    </summary>
    
    
      <category term="Apache" scheme="%5Bobject%20Object%5D/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>restful 接口设计</title>
    <link href="%5Bobject%20Object%5D/2017/06/09/restful/"/>
    <id>[object Object]/2017/06/09/restful/</id>
    <published>2017-06-09T10:20:03.000Z</published>
    <updated>2017-07-13T01:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在工作中需要实现一个跨平台，易实现，方便调试排错的接口。<br>经过考虑之后，发现restful接口是非常合适的。</p>
<p>接口的实现是基于c++的boost的。所以有两个非常重要的boost库需要介绍一下。</p>
<p>首先我们需要想想我们需要怎样的借口调用方式，健壮的，易扩展的。</p>
<pre><code>RequestHandler requesthandler;
requesthandler.set_handler(&quot;sessions&quot;)
  .get(boost::bind(&amp;handle_sessions_get_method, _1, _2))
  .post(boost::bind(&amp;handle_sessions_post_method, _1, _2, boost::ref(vm)))
  .put(boost::bind(&amp;handle_sessions_put_method, _1, _2))
  .del(boost::bind(&amp;handle_sessions_delete_method, _1, _2));
</code></pre><p>我们在这个接口中注册请求处理函数，分别处理 get，post，put，delete请求。</p>
<p><strong>Q1：为什么所有的method请求是连接在一起的？</strong><br>我们需要保持source的唯一性，一个source只能被声明一次，</p>
<pre><code>/*  -&gt;  表示 key-&gt;value 的数据结构 */
source: sessions
action: get ,post, put, del
callback: handle_sessions_*_method

                           ++++++++++++++++++++++++++++++++++++++++++++
    +++++++++++++          |  get   -&gt;  handle_sessions_get_method    |
    |  sessions |  ---&gt;    |  post  -&gt;  handle_sessions_get_method    |
    +++++++++++++          |  put   -&gt;  handle_sessions_put_method    |
                           |  del   -&gt;  handle_sessions_delete_method |
                           ++++++++++++++++++++++++++++++++++++++++++++
</code></pre><p>整个的调用就是两个 key-&gt; value 的形式</p>
<p><strong>boost::functon</strong></p>
<pre><code>typedef std::function&lt;void(response &amp;, const request &amp;)&gt;  served_req_handler;
</code></pre><p>boost::function 的boost提供的一个回调函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在工作中需要实现一个跨平台，易实现，方便调试排错的接口。&lt;br&gt;经过考虑之后，发现restful接口是非常合适的。&lt;/p&gt;
&lt;p&gt;接口的实现是基于c++的boost的。所以有两个非常重要的boost库需要介绍一下。&lt;/p&gt;
&lt;p&gt;首先我们需要想想我们需要怎样的借口调用方
    
    </summary>
    
    
      <category term="Tech" scheme="%5Bobject%20Object%5D/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>背诵</title>
    <link href="%5Bobject%20Object%5D/2017/06/04/recitation/"/>
    <id>[object Object]/2017/06/04/recitation/</id>
    <published>2017-06-04T15:26:07.000Z</published>
    <updated>2017-06-04T15:39:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个周末都在准备周一需要背诵的材料。<br>仔细想想，我花了两天的准备时间，自己真正花在背诵的时间其实很少很少。<br>究其原因，是大部分的时间都不再状态，什么叫不在状态，<br>就是你想背诵的时候，脑袋里面总是有其它的挥之不去的东西。<br>其实对需要背诵的材料是非常非常的排斥，在内心里面不愿意去背诵它。<br>背诵的过程也不像敲代码一样有明显的奖励过程。会让自己非常的兴奋。<br>背诵的过程是非常的痛苦与平淡。<br>像是小和尚念经，有口无心一样。</p>
<p>现在想想，你花了两天时间都在准备这个，其实这是一个非常大的误区。<br>背诵是不可能百分百在状态的。<br>人在一天中不同的状态适合处理不同的事务。<br>就像早晨是适合背诵东西的，因为此刻你的心思无杂念。<br>晚上也是适合的，因为此刻是比较安静的。<br>但是上午或者下午对于我却是不太适合，<br>我是逻辑型思考，所有的东西需要依靠逻辑来串联到一起，就像一个哈希表一样。</p>
<p>说的这么多，其实想要表达的是，不要太强求自己，合理规划时间，<br>在对的时间做对的事情，在合适的时间做合适的事情。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个周末都在准备周一需要背诵的材料。&lt;br&gt;仔细想想，我花了两天的准备时间，自己真正花在背诵的时间其实很少很少。&lt;br&gt;究其原因，是大部分的时间都不再状态，什么叫不在状态，&lt;br&gt;就是你想背诵的时候，脑袋里面总是有其它的挥之不去的东西。&lt;br&gt;其实对需要背诵的材料是非常非常
    
    </summary>
    
    
      <category term="Think" scheme="%5Bobject%20Object%5D/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>早班地铁的爱情</title>
    <link href="%5Bobject%20Object%5D/2017/06/03/subway/"/>
    <id>[object Object]/2017/06/03/subway/</id>
    <published>2017-06-03T02:20:08.000Z</published>
    <updated>2017-06-03T12:20:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>王二此刻就在早班的地铁上面，不要问为什么他此刻在早班的地铁上，<br>因为他住在居民区中，而公司要穿过整个城市才能到达，<br>不要问为什么他没有在在公司附近，<br>也不要问他为什么住的地方去公司要穿过整个城市。</p>
<p>他从来没有思考过，因为这是一切自然而然的选择。<br>因为住的地方便宜，上一家公司辞退他之后，<br>这是唯一一家要他的公司。而这家公司刚好就在城市的另一头。<br>好像所有的事情就是这么的巧合。</p>
<p>这是一座号称魔都的城市，你能够想象一个小蜂窝吗？<br>就是一个蜂窝的感觉，你永远不知道你里面钻出多少只蜜蜂，<br>又钻进来多少只蚂蚁，你只能在捅掉这个蜂窝的时候，<br>根据你的恐惧程度逃跑的速度来判断有多少蜜蜂来。<br>所以你不要低估魔都的魔力。</p>
<p>说到蜂窝，不得不提它那六边形蜂房，在数学上面，<br>六边形结构可以在一定体积里，能用最少的材料去建造一個最宽坦的巢室。<br>而且节省材料。再从它们采摘的花粉，投以酿造的蜂蜜，<br>按照这种方式，你养多少的工蜂都不要紧来。唯一感到遗憾都是<br>一旦工蜂无法采集蜂蜜，它们都死期就到来了。<br>但是我想它们非常快乐的，因为我从小就知道劳动是使人快乐的。<br>王二小的时候是非常淘气的，或许是嫉妒蜜蜂总是有事情做，<br>而自己总是无所事事的，所以他见一个就捅一个，然后拔腿就跑，<br>大多数的时候他都是成功的，反而是有一次他在无意之中碰到一个<br>马蜂窝，在毫无防备的情况的变成了小胖子。</p>
<p>都说现在世界上最美妙都事情就是想入非非了。你可以想象任何都东西，<br>江上清风，山间明月，闭上眼镜，你就处在另一个世界了。<br>小隐隐于野，中隐隐于市，大隐隐于朝。现在大隐隐于地铁了。<br>你埋在地铁中。王二正在想着自己已经成为大隐者都时候，手机冷不丁<br>的正中砸向王二的脑袋，一下子把他从江湖之远，拉向地铁之高。</p>
<p>关于地铁，可能跟你现在想象的不太一样，其实是可以理解的。<br>你想想，如果你要最大程度利用地铁里面的空间，你会怎么做呢？<br>是的，可能你已经想到的，顶上也是可以站人的。既然你已经想到<br>地铁底部科研站人，那么你肯定也想到了，只要有顶的地方就可以正常<br>走动了。</p>
<p>关于这一点，人们早就想到了，如果所以你看到的顶部都可以走都话，<br>这个世界瞬间就可以增大两边或者更多都生存空间。<br>其实这是一个非常简单都道理，但是人们就这样的活着，<br>因为这一切都很正常啊，所以人都是这么过来的。<br>就像活在厕所中的蛆一样，从出生的第一眼就是在这里。<br>所以的一切都是合情合理的，没有什么不对，<br>你看过在天空中飞翔的蛆吗？那是不可能的。</p>
<p>一天一个教授在人挤人的地铁中想入非非，为什么顶上不可以站人呢？<br>这又是一项想入非非的奇迹，这真实灵感的发源地。<br>这位教授当时正在为科研申请项目头疼，当他为这个荒唐的想法<br>感到震惊的时候，死猪不拍开水烫，为什么不试一下呢？<br>然后这个伟大的项目在莫名其妙中就获得了科研经费。</p>
<p>但是这个伟大的想法扼杀了另一个伟大的想法，因为手机砸到<br>了王二的头上。把这个伟大的想入非非就一下子砸没了。这其实<br>算是一个bug，在正常流的时候，在顶上的人和他有关联的东西重力<br>方向是一致的。也就是说，你站在顶上，东西掉下去，是朝这顶上去的。<br>你站在地上，你东西是朝向地上的。这种bug存在的机率是十万之一。<br>有人统计过，这个世界上的人一见钟情的概率也是十万之一。<br>如果你被你顶上的人砸中的时候，这是决定命运的时刻，不是闹着玩的。<br>所以你出门的时候要梳妆打扮好。命运之门就存在于bug之中。</p>
<p>这一刻，王二却异常紧张起来。因为他出门的时候从没有想到<br>今天会被手机砸到，就像牛顿从不能预测那天被苹果砸到，然后<br>变成了世界上最伟大的物理学家之一一样。命运之门就这么不经意<br>到来。</p>
<p>后来有朋友问他被砸那一刻的感想，他那时候喝了一点酒，<br>于是随口就说：那时候我非常的担心，担心如果同样是一个男的怎么办，<br>如果已经是阿姨奶奶了怎么办，如果缺胳膊少腿怎么办，甚至他还<br>想到此刻地球毁灭了要怎么办，所以他就在那里呆立了一秒钟，<br>脑袋了翻江倒海，从古至今穿越了几万年，想到了这个世界<br>上的所有的可能。然后在向上望的一瞬间，我仿佛又向前<br>穿越了一百年，想到了与顶上的人的所有的可能。<br>事实就是这样，在那一刻，我遍历了世界上的所以可能。<br>然后遇到了她。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;王二此刻就在早班的地铁上面，不要问为什么他此刻在早班的地铁上，&lt;br&gt;因为他住在居民区中，而公司要穿过整个城市才能到达，&lt;br&gt;不要问为什么他没有在在公司附近，&lt;br&gt;也不要问他为什么住的地方去公司要穿过整个城市。&lt;/p&gt;
&lt;p&gt;他从来没有思考过，因为这是一切自然而然的选择
    
    </summary>
    
    
      <category term="王小波门下走狗" scheme="%5Bobject%20Object%5D/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2%E9%97%A8%E4%B8%8B%E8%B5%B0%E7%8B%97/"/>
    
  </entry>
  
  <entry>
    <title>无序</title>
    <link href="%5Bobject%20Object%5D/2017/05/30/longway/"/>
    <id>[object Object]/2017/05/30/longway/</id>
    <published>2017-05-30T09:25:42.000Z</published>
    <updated>2017-06-03T02:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>你装饰了别人的梦<br>明月装饰了你的窗子，<br>你站在桥上看风景，<br>看风景人在楼上看你。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你装饰了别人的梦&lt;br&gt;明月装饰了你的窗子，&lt;br&gt;你站在桥上看风景，&lt;br&gt;看风景人在楼上看你。&lt;/p&gt;

    
    </summary>
    
    
      <category term="一个程序员都日常" scheme="%5Bobject%20Object%5D/tags/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>消失的五月</title>
    <link href="%5Bobject%20Object%5D/2017/05/28/disMay/"/>
    <id>[object Object]/2017/05/28/disMay/</id>
    <published>2017-05-28T11:04:21.000Z</published>
    <updated>2017-05-28T12:16:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>五月好像一瞬间就过去了，在中间没有留下任何的痕迹。<br>生活仿佛没有波澜的心跳线。<br>火车穿过悠长的隧道。窗外失去了风景。<br>一切都在轨道上面。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;五月好像一瞬间就过去了，在中间没有留下任何的痕迹。&lt;br&gt;生活仿佛没有波澜的心跳线。&lt;br&gt;火车穿过悠长的隧道。窗外失去了风景。&lt;br&gt;一切都在轨道上面。&lt;/p&gt;

    
    </summary>
    
    
      <category term="一个程序员的日常" scheme="%5Bobject%20Object%5D/tags/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Apache 压力测试后的大量本地连接</title>
    <link href="%5Bobject%20Object%5D/2017/05/20/20170520/"/>
    <id>[object Object]/2017/05/20/20170520/</id>
    <published>2017-05-20T05:32:10.000Z</published>
    <updated>2017-05-28T12:06:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在对Apache（prefork多进程模式）进行压力测试对时候，<br>发现一旦停止压力测试对时候。<br>会出现非常多的本地连接<br><a id="more"></a> </p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在对Apache（prefork多进程模式）进行压力测试对时候，<br>客户端IP：192.168.41.96<br>网关IP和端口; 0.0.0.0:447<br>发现一旦停止压力测试对时候。<br>使用 netstat -an | grep 127<br>会出现非常多的 127.0.0.1:447 连接</p>
<pre><code>tcp        0      0 127.0.0.1:38984         127.0.0.1:447           TIME_WAIT
tcp        0      0 127.0.0.1:38994         127.0.0.1:447           TIME_WAIT
</code></pre><p>查看的时候连接都已经是 TIME_WAIT 的状态，无法查看它是通过哪些进程查看它建立连接。<br>我们怀疑这些连接可能对性能会有影响。<br>所以对这个问题进行了排查。</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>因为所有的127.0.0.1的端口都与447端口断开连接，又因为这些无法有效都用gdb调试。<br>所以使用 strace 的方式跟踪进程。</p>
<blockquote>
<p>strace -p 683 -o filename_childpid<br>strace -p 899 -o filename_masterpid</p>
</blockquote>
<p>filename_childpid  是在压力测试的时候临时创建出来的子进程<br>filename_masterpid 是Apache的主进程</p>
<p>在压力测试时候出现的子进程中可以看到</p>
<pre><code>accept(3, {sa_family=AF_INET, sin_port=htons(36448), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, [16]) = 6
getsockname(6, {sa_family=AF_INET, sin_port=htons(447), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, [16]) = 0
</code></pre><p>发现这个子进程是accept了连接。但是这些环回地址是如何产生的？</p>
<p>查看主进程的 strace 文件</p>
<pre><code>waitpid(-1, 0xbffffa18, WNOHANG|WUNTRACED) = 0
select(0, NULL, NULL, NULL, {1, 0})     = 0 (Timeout)
write(5, &quot;!&quot;, 1)                        = 1
socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 9
fcntl64(9, F_GETFL)                     = 0x2 (flags O_RDWR)
fcntl64(9, F_SETFL, O_RDWR|O_NONBLOCK)  = 0
connect(9, {sa_family=AF_INET, sin_port=htons(447), sin_addr=inet_addr(&quot;0.0.0.0&quot;)}, 16) = -1 EINPROGRESS (Operation now in progress)
poll([{fd=9, events=POLLOUT, revents=POLLOUT}], 1, 3000) = 1
getsockopt(9, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
close(9)                                = 0
--- SIGCHLD (Child exited) @ 0 (0) ---
</code></pre><p>从这里发现Apache的主进程发了connect连接，然后自己断开连接。<br>但是为什么回出现这种情况呢？需要进一步查看代码查找原因。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>压力测试的时候起了非常多的子进程。<br>但是压力测试之后不需要那么多的进程。<br>此时临时建立的子进程都阻塞在select上面。<br>Apache采用都策略就是主进程与阻塞都子进程建立连接，<br>然后关闭连接，所以看到都现象如上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在对Apache（prefork多进程模式）进行压力测试对时候，&lt;br&gt;发现一旦停止压力测试对时候。&lt;br&gt;会出现非常多的本地连接&lt;br&gt;
    
    </summary>
    
    
      <category term="Tech" scheme="%5Bobject%20Object%5D/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>搬家</title>
    <link href="%5Bobject%20Object%5D/2017/05/06/20170506/"/>
    <id>[object Object]/2017/05/06/20170506/</id>
    <published>2017-05-06T09:21:59.000Z</published>
    <updated>2017-05-28T12:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近搬了新的住处，忽然不明白自己为什么在那里住了2年。<br><a id="more"></a></p>
<p>最近搬了新的住处，在那个地方也住了两年，现在回想一下，<br>为什么自己会忍受那样的住了2年，我为什么要这么说呢？<br>因为那时候刚来上海，所以对生活对要求也不是很高，<br>是跟朋友合租的，地理位置挺方便的，而且价格也挺合理，<br>造成的结果就是房子比较老，所以一切配套的都是老家具。<br>因为对这个地方最初对定位就是睡觉。所以满足生活的基本<br>要求就满足了。就这样度过了两年。</p>
<p>现在搬到公司附近，有了属于自己的独立的空间。<br>而且家具都是比较新的。这一切突然激发了自己的装饰欲望。</p>
<p>于是在地板上铺好地毯。买了自己一直想种的花。<br></p>
<p>买了梵高的星空，买了花瓶。<br>买了衣架，买了真空袋把一切都收拾的整整齐齐。<br>就连常年治不好的叠被子也因为不和谐而变得自然。</p>
<p>一直知道自己需要什么，可是在老的住处，看着<br>那些陈旧的老东西，所有都还是老样子，没有改变。</p>
<p>这一切都从我拥有了一双象牙筷子说起。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近搬了新的住处，忽然不明白自己为什么在那里住了2年。&lt;br&gt;
    
    </summary>
    
    
      <category term="Think" scheme="%5Bobject%20Object%5D/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>系统内存不足</title>
    <link href="%5Bobject%20Object%5D/2017/04/27/outOfMemory/"/>
    <id>[object Object]/2017/04/27/outOfMemory/</id>
    <published>2017-04-27T02:22:15.000Z</published>
    <updated>2017-05-28T12:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们会面临一些非常情况的现象，<br>没有异常的情况下进程无缘无故的退出，<br>无法写如日志文件。<br>非常奇怪的错误抛出在终端。<br><a id="more"></a></p>
<h2 id="现象及分析"><a href="#现象及分析" class="headerlink" title="现象及分析"></a>现象及分析</h2><p>有时候我们会面临一些非常情况的现象，<br>没有异常的情况下进程无缘无故的退出，<br>无法写如日志文件。<br>非常奇怪的错误抛出在终端。</p>
<p>这个时候就需要查看一下系统日志 kern.log 了。</p>
<pre><code>MAIN kernel: [17832.300370]  [&lt;c1090380&gt;] ? oom_kill_process+0x60/0x201
MAIN kernel: [17832.300408]  [&lt;c10908fd&gt;] ? __out_of_memory+0xf4/0x107
MAIN kernel: [17832.300445]  [&lt;c109096a&gt;] ? out_of_memory+0x5a/0x7c
MAIN kernel: [17832.300482]  [&lt;c109322c&gt;] ? __alloc_pages_nodemask+0x3ef/0x4d9
MAIN kernel: [17832.300522]  [&lt;c109460d&gt;] ? __do_page_cache_readahead+0x98/0x16b
MAIN kernel: [17832.300562]  [&lt;c10946f4&gt;] ? ra_submit+0x14/0x18
MAIN kernel: [17832.300597]  [&lt;c108ec9a&gt;] ? filemap_fault+0x16d/0x2e6
MAIN kernel: [17832.300634]  [&lt;c10a0c9a&gt;] ? __do_fault+0x53/0x3fb
MAIN kernel: [17832.300670]  [&lt;c10a2f56&gt;] ? handle_mm_fault+0x4d1/0xa22
MAIN kernel: [17832.300708]  [&lt;c1144ae3&gt;] ? copy_to_user+0x29/0xf8
MAIN kernel: [17832.300745]  [&lt;c10c6b9a&gt;] ? poll_select_copy_remaining+0xbd/0xd9
MAIN kernel: [17832.300785]  [&lt;c12830a8&gt;] ? do_page_fault+0x2f1/0x307
MAIN kernel: [17832.300822]  [&lt;c1282db7&gt;] ? do_page_fault+0x0/0x307
MAIN kernel: [17832.300857]  [&lt;c12815e3&gt;] ? error_code+0x73/0x78
</code></pre><p>这个时候我们可以发现内存已经不足了。<br>Linux的保护机制在杀内存消耗大的进程。<br>所以会有进程无缘无故的推出。<br>有一些日志是先写到buffer的内存中，然后再调用日志接口把内存中的日志刷到文件中。<br>此时内存已经不足了，所以内存中已经写不进去了。<br>最终我们看到的现象就是写不到文件中。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="内存确实不足"><a href="#内存确实不足" class="headerlink" title="内存确实不足"></a>内存确实不足</h3><p>最简单的办法就是直接使用 top 工具。<br>使用Memory usage的排序方式，实时查看进程的内存占用情况。<br>查看哪个服务占用了非常大的内存空间。<br>检查一下为什么占用的内存空间非常大。<br>是不是真的需要。</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>使用 valgrind 的工具运行程序检测内存释放出现泄漏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候我们会面临一些非常情况的现象，&lt;br&gt;没有异常的情况下进程无缘无故的退出，&lt;br&gt;无法写如日志文件。&lt;br&gt;非常奇怪的错误抛出在终端。&lt;br&gt;
    
    </summary>
    
    
      <category term="Tech" scheme="%5Bobject%20Object%5D/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>TCP 握手</title>
    <link href="%5Bobject%20Object%5D/2017/03/28/tcp-handshark/"/>
    <id>[object Object]/2017/03/28/tcp-handshark/</id>
    <published>2017-03-28T13:44:05.000Z</published>
    <updated>2017-05-28T12:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>tcp 报头的各个字段的作用<br>想象一下自己去设计一个TCP协议，最中的是保证可靠性。因为每个报文都是要包含这些字段，所以你要怎么保证它的简洁性，不浪费资源。<br><a id="more"></a></p>
<pre><code>source port:  源端口
destination port: 目标端口
sequence number: 序号，每一个TCP报文段都会有一个序列，序列号字段段值其实是本报文段所发送段第一个字节的序号，通过序号来确保服务的可靠性和有序性。
ack number:确认号
Data offset:数据偏移
Reserved:保留字段
URG(urgent)：紧急指针
ACK ：确认字段 
PSH：推送字段
RST：复位字段
SYN：同步字段
FIN：终止字段
Windows size：窗口大小
checksum：检验和
Urgent pointer：紧急指针
options：选项
</code></pre><h3 id="tcp-三次握手"><a href="#tcp-三次握手" class="headerlink" title="tcp 三次握手"></a>tcp 三次握手</h3><p>为什么tcp握手需要三次？这个保证了什么东西？</p>
<ul>
<li>客户端发送一个 SYN 给服务端。</li>
<li>服务端返回一个ack和syn给客户端确认。</li>
<li>客户端在返回一个ack确认。tcp连接建立。</li>
</ul>
<p>如果只有两次握手会怎样？<br>客户端发送了一个连接请求的SYN，但是由于网络问题，以至这个连接释放之后才到达服务端，<br>这时候服务器发送 ack 和 syn 给客户端。<br>如果此时就建立连接，由于客户端已经废弃了这个 SYN，所以这个连接客户端什么<br>都不会发送，白白浪费了资源。</p>
<p>DDoS攻击的也有相似的原理</p>
<blockquote>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
</blockquote>
<h3 id="tcp-四次挥手"><a href="#tcp-四次挥手" class="headerlink" title="tcp 四次挥手"></a>tcp 四次挥手</h3><ul>
<li>客户端发送一个 FIN 给服务端</li>
<li>服务端发送一个ACK 确定</li>
<li>服务端再发送一个 FIN 接收服务端的连接</li>
<li>客户端发送 ACK 确定后关闭连接</li>
</ul>
<p>半连接的时候是怎么处理的？<br>为什么要四次握手？<br>time_wait 的作用是什么？危害是什么？</p>
<p>tcp 连接是全双工的，所以一边发送FIN，都需要另一边 ACK 确定。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tcp 报头的各个字段的作用&lt;br&gt;想象一下自己去设计一个TCP协议，最中的是保证可靠性。因为每个报文都是要包含这些字段，所以你要怎么保证它的简洁性，不浪费资源。&lt;br&gt;
    
    </summary>
    
    
      <category term="Tech" scheme="%5Bobject%20Object%5D/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>apache多种debug调试方式</title>
    <link href="%5Bobject%20Object%5D/2017/03/22/apache-debug/"/>
    <id>[object Object]/2017/03/22/apache-debug/</id>
    <published>2017-03-22T12:02:01.000Z</published>
    <updated>2017-03-22T12:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>将正在测试的机器上都打开 coredump，等待重现<ul>
<li>在linux系统中执行 ulimit -c unlimited</li>
<li>配置文件中添加 CoreDumpDirectory directory</li>
</ul>
</li>
</ul>
<ul>
<li>尝试 valgrind 追踪内存错误<ul>
<li>valgrind –tool=memcheck –leak-check=yes –show-reachable=yes –error-limit=no  apache</li>
</ul>
</li>
</ul>
<ul>
<li>strace 调试<ul>
<li>strace -f -p pid</li>
</ul>
</li>
</ul>
<ul>
<li>尝试用 gdb 启动，等待重现<ul>
<li>使用gdb启动服务，直接run，等待进程崩溃</li>
</ul>
</li>
</ul>
<ul>
<li>apache信号调试<ul>
<li>gdb attach进主线程或者需要的线程</li>
<li>breakpoints</li>
<li>continue</li>
<li>访问服务或者发信号</li>
<li>gdb接收信号，然后continue</li>
<li>调试</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;将正在测试的机器上都打开 coredump，等待重现&lt;ul&gt;
&lt;li&gt;在linux系统中执行 ulimit -c unlimited&lt;/li&gt;
&lt;li&gt;配置文件中添加 CoreDumpDirectory directory&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/
    
    </summary>
    
    
      <category term="Tech" scheme="%5Bobject%20Object%5D/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>水墨画的扩展</title>
    <link href="%5Bobject%20Object%5D/2017/02/15/wash-painting/"/>
    <id>[object Object]/2017/02/15/wash-painting/</id>
    <published>2017-02-15T01:02:05.000Z</published>
    <updated>2017-02-15T13:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>高与远</strong></p>
<ul>
<li>水墨画的山水图的结构是非常紧凑的,仿佛有人在极目远望，<br>所有的东西都压缩在一起，视线越远，山峰就变得越高。</li>
</ul>
<p><strong>层次</strong></p>
<p>水墨虽然都是黑色的，但是浓与淡将空间区分开来，<br>在表现早晨的水雾的时候，效果尤其明显。<br>一些清晰可见，一些若隐若现。</p>
<p><strong>维度</strong></p>
<p>将这些山水画45度角摆放的时候，会产生一种奇艺的效果，<br>仿佛二维的图形有了三维的效果。山水变得立体起来。</p>
<p><strong>时间</strong></p>
<p>仿佛整个世界凝聚于这个瞬间，这个瞬间的所有变化在<br>意想不到的瞬间出现，然后凝聚。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;高与远&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水墨画的山水图的结构是非常紧凑的,仿佛有人在极目远望，&lt;br&gt;所有的东西都压缩在一起，视线越远，山峰就变得越高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;层次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;水墨虽然都
    
    </summary>
    
    
      <category term="Think" scheme="%5Bobject%20Object%5D/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>thread</title>
    <link href="%5Bobject%20Object%5D/2017/02/12/thread/"/>
    <id>[object Object]/2017/02/12/thread/</id>
    <published>2017-02-12T06:57:05.000Z</published>
    <updated>2017-05-28T12:20:37.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>只要我时间了，我就把这本书看完。
如果我有很多钱，我就要去全世界旅游。
</code></pre><a id="more"></a>

<p>总是喜欢信誓旦旦的对别人说着一些话，<br>不知道最后多少人达成了目标。<br>就像小时候想要的那个模型。<br>现在可以轻而易举的买下小时候的想要的任何东西。<br>可是突然失去了对这件事情的乐趣。<br>时间与环境的变化，那么事情本事早就失去了它原本的意义。</p>
<p>太多时候总喜欢用如果只要达到什么条件，<br>那么我就要做什么。喜欢把生活一步一步的规划，<br>达到一个目标之后，才开始进行下一步。<br>如果有一步陷入了困境，那么就一直阻塞在那一步。</p>
<p>计算机人员在解释多核的时候，喜欢用一个人在多项任务<br>之间切换得够快，那么像是在同时处理多件事情一样。<br>但是我们不能像孙悟空或者技术总监一样分身。分配人员<br>同时处理不同的事情。</p>
<p>但是可以像线程一样。<br>在保证主线程正常运行的时候，<br>使用多线程的方法，从现在慢慢就开始做自己喜欢的事情。<br>但是也要保证线程安全。</p>
<p>refer: <a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" target="_blank" rel="external">thread</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;只要我时间了，我就把这本书看完。
如果我有很多钱，我就要去全世界旅游。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Tech, Think" scheme="%5Bobject%20Object%5D/tags/Tech-Think/"/>
    
  </entry>
  
  <entry>
    <title>问问题</title>
    <link href="%5Bobject%20Object%5D/2017/02/08/ask-question/"/>
    <id>[object Object]/2017/02/08/ask-question/</id>
    <published>2017-02-08T10:23:00.000Z</published>
    <updated>2017-02-08T10:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>在问问题之前不需要问在不在，一般上班时间并且头像是亮着的话人是在的。</li>
<li>这个项目的背景是怎样的？问题是在什么时候产生的，是在部署的时候还是网关在运行的时候产生的，如果是网关在运行的时候产生的，那么在之前有没有进行过什么操作。需要能够描述问题产生原因。而不是只是描述一个结果。</li>
<li>问题能否重现，重现的方法是什么，如果不能重现，说明不能重现的理由。（在自己电脑中使用虚拟机搭建网关的环境）</li>
<li>提供网关的版本号，升级包记录等相关信息。</li>
<li>需要时要能够使用tcpdump到网关后台抓包。平时需要学会使用tcpdump和wireshare等简单的工具。</li>
<li>简单的学会一些linux的命令行，vim等操作。</li>
<li>问问题之前先参考wiki或者FAQ上是否存在类似的问题。</li>
<li>学会怎么问问题。提供以上信息，并且能够一次性把问题描述清楚。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在问问题之前不需要问在不在，一般上班时间并且头像是亮着的话人是在的。&lt;/li&gt;
&lt;li&gt;这个项目的背景是怎样的？问题是在什么时候产生的，是在部署的时候还是网关在运行的时候产生的，如果是网关在运行的时候产生的，那么在之前有没有进行过什么操作。需要能够描述问题产生原
    
    </summary>
    
    
      <category term="Tech" scheme="%5Bobject%20Object%5D/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>Apache内存管理</title>
    <link href="%5Bobject%20Object%5D/2017/02/06/apache-pool/"/>
    <id>[object Object]/2017/02/06/apache-pool/</id>
    <published>2017-02-06T11:47:33.000Z</published>
    <updated>2017-05-28T12:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Apache 提供了自己的内存和资源管理方式，称作内存池，内存池在apache中任何一个阶段被使用，所以也被外部模块使用。<br>内存池可以管理内存，Sockets 和进程等服务系统所有的资源。<br><a id="more"></a></p>
<p>内存池的使用可以降低程序设计错误的可能性。在程序中如果由于疏忽或错误造成程序未能释放已经不再使用的内存，造成内存泄露。<br>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，<br>从而造成了内存的浪费，其它的程序就不能够再使用这个内存段。</p>
<p>客户端的程序因为运行不是非常长时间，退出后操作系统会自动释放资源，所以不是造成太大的危害。但是在服务端端程序由于长期运行，<br>即使是一点地内存泄漏由于长期内存泄露造成服务端的崩溃。</p>
<p>尤其需要注意Sockets。如果建立了一个Socket，但是在业务完成时没有释放它，那么其它的程序就不能使用这块内存。这些不断建立但<br>是未释放的Sockets会造成内存，CPU被占满。此时服务端一定会崩溃。许多服务端现在基本都是以多线程或者多进程的方式工作，这些<br>进程或者线程如果不按设计退出只能被管理员中断。如果一个程序不停止运行，那么服务端端资源会被立马占满并且崩溃。</p>
<p>随着内存池的使用，开发者可以在一个已知生命周期的内存池中使用内存，sockets和进程。一旦这个内存池被摧毁，那么所有的资源都<br>会自动的释放。这样就只有一些仔细考虑后额外的例程才会需要考虑释放内存的事情。这样就变得更简单明了，减少了开发者的负担。</p>
<p>重要的是，内存池可以提升服务器的性能。通常一个程序使用和释放内存，由于系统需要从虚拟内存中分配和释放内存，这些会造成<br>许多的开销，这将显著的降低性能。并且，不管请求了多少内存，系统通常分配一个最小数量的空间。<br>那么这将造成许多小的内存空间被浪费。经常这样做的话，那么你需要关注这些小内存的价值了.</p>
<h3 id="内建池和生命周期"><a href="#内建池和生命周期" class="headerlink" title="内建池和生命周期"></a>内建池和生命周期</h3>
<p>Apache内建的内存池都有不同的生命周期，如上图所示，该图描述了池的继承的层次结构。pglobal存在于服务器的真个运行周期，<br>pchaild存在于整个子虚拟机主机的生命周期，pconn是每一个连接的生命周期，preq是每一个请求的生命周期。通常开发者使用<br>最小的生命周期最小存储空间最小存放数据。</p>
<p>如果开发者需要一个非常大的内存空间，而且没有一个合适生命周期的内存池。一个任意内建池的子池可以被创建。程序可以像<br>内建池一样使用这个内存池，也可以在不需要这个内存池的时候释放它。如果忘记了释放这个内存池，那么在它的父池被释放的<br>时候它会被自动释放。释放pglobal的时候，所以的子池都将被自动释放。每一个连接池是子服务池处理连接，所有的请求池都<br>是对应了连接池。</p>
<h3 id="内存池的内部结构"><a href="#内存池的内部结构" class="headerlink" title="内存池的内部结构"></a>内存池的内部结构</h3>
<p>如上图所示，一个池内部链接了一系列的子池，数据块，进程和回调函数。如果需要分配内存需要使用预定义的函数。这些函数<br>不只是分配内存，并且也可以释放内存。同样的进程也可以通过内存池建立，内存释放的时候进程结束。此外，每个池可以保存<br>关于在销毁所有存储器之前被调用的函数的信息。这样文件处理程序和套接字都可以注册一个池去销毁它。</p>
<p>当一个内存池被销毁的时候，apache首先回调清理函数。所有注册的文件句柄和Sockets将被关闭。之后，池讲终止所有的注册<br>和进程。这些结束之后，数据块就被释放。通常apache并不是真的释放被其它程序使用的内存。而是将它从池中删除，将这段<br>内存放入空闲的内存块中。这样就将分配和释放内存的消耗降至最低。内核将立即分配这些空闲的内存。只有在池中所有的内<br>存都用完时才需要分配新的空间。</p>
<p>refer: <a href="http://www.fmc-modeling.org/category/projects/apache/amp/4_6Memory_resource.html" target="_blank" rel="external">Memory_resource</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache 提供了自己的内存和资源管理方式，称作内存池，内存池在apache中任何一个阶段被使用，所以也被外部模块使用。&lt;br&gt;内存池可以管理内存，Sockets 和进程等服务系统所有的资源。&lt;br&gt;
    
    </summary>
    
    
      <category term="Tech" scheme="%5Bobject%20Object%5D/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>重复</title>
    <link href="%5Bobject%20Object%5D/2017/02/05/repetition-work/"/>
    <id>[object Object]/2017/02/05/repetition-work/</id>
    <published>2017-02-05T14:36:33.000Z</published>
    <updated>2017-02-05T14:36:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>想想你去年重复了哪些工作，哪些工作占用了你的大量时间，<br>技术支持的时候是对方没有描述清楚问题，还是自己没有理解好问题。<br>是对方在现场操作太慢，还是自己提供的文档不够齐全。</p>
<p>在工作的时候哪些场景会让你不开心，不开心的原因是什么，<br>是因为事情本身，还是这种交互之间占据了太多时间，是对方的原因，还是自己没有讲清楚的原因。</p>
<p>什么场景下你会感到非常的烦躁，是因为工作事情本身的原因，<br>还是没有休息好的原因。</p>
<p>什么东西会影响你工作的效率，突然的电话的打扰，消息，邮箱的打扰。<br>身边同事的打扰，什么打扰你可以忍受，什么打扰你不可以忍受。<br>什么东西会促进你的工作效率，在工作的时候听音乐可以促进你的工作效率吗？<br>在什么情况下你需要音乐去促进你的效率。<br>还有什么硬件或者软件可以促进你的效率，你有争取去改进你的原有的什么方式吗？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想想你去年重复了哪些工作，哪些工作占用了你的大量时间，&lt;br&gt;技术支持的时候是对方没有描述清楚问题，还是自己没有理解好问题。&lt;br&gt;是对方在现场操作太慢，还是自己提供的文档不够齐全。&lt;/p&gt;
&lt;p&gt;在工作的时候哪些场景会让你不开心，不开心的原因是什么，&lt;br&gt;是因为事情本身
    
    </summary>
    
    
      <category term="Tech" scheme="%5Bobject%20Object%5D/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>人头马身</title>
    <link href="%5Bobject%20Object%5D/2016/10/25/20161025/"/>
    <id>[object Object]/2016/10/25/20161025/</id>
    <published>2016-10-25T00:48:22.000Z</published>
    <updated>2016-11-06T07:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>(一)</p>
<p>来到这个城市已经十年，时间在指尖上溜过，却什么也不曾留下，一无所有的来，可是比到来变得更加得一无所有，<br>来的时候以为能够在这个城市留下辉煌，可是我是留下来，也把我的卑微也留下。<br>如果我手中有一把剑，我会成为一位剑客，纵横四海，无所畏惧，可是我手中没有剑。<br>如果我会跳舞，我会在月光下，在舞台中央，在所有的目光中灼灼生辉，可是我不会跳舞。<br>如果我活在魏晋，我会成为一个放浪形骸的人，饮觞取酒，或宠辱不惊，或尽情悲痛，可是我活在不一样的时代。<br>如果，如果，我只是一个普普通通的一个人，什么也不会，什么也做不了。<br>如果我手中有一个键盘，是的，我手中现在只剩下键盘。看着屏幕，顾影自怜。<br>我是一名程序员，版本更新之后，旧的代码已经面目全非。时间也就变得面目全非。</p>
<p>你是否感觉到，这个世界每时每刻都在变化，在你闭上眼的那一刻，在你早上醒过来的那一刻，你已经转换到了另一个时空，<br>细微的变化并没有让你察觉，可是在睁开眼睛的那一刻，你是否有一丝的恍惚?<br>你不能同时存在一条河里两次，你不动，水已经动了，你跟着水动，位置已经变了。<br>我已经变得越来越恍惚，越来越心不在焉，头脑昏沉。我的意志感觉不受束缚，手也已经开始不受控制。<br>“你好，我叫陈晓，来自你的平行世界。”<br>仿佛一瞬间清醒过来，感觉到恐惧，难道那个世界的科技已经发达到了这种程度。<br>不知道为什么那个平行世界会找上我,难道是他能够感受到每个时间线，在所有的时间线上选择了我。或者我们身上有着一个相同的时间节点。<br>记得那是一个非常普通的的晚上，我坐在我的电脑前面，可能那个时候我意外的成为了一个叠加态，在理论物理和工作两个态之间做选择。<br>我的世界坍塌在工作上面，而另一个我坍塌在做科研，而且是理论物理的方向。<br>“如果你能够看到，那么在明天凌晨2点到xx区xx路xx广场见面。”</p>
<p>刚上出租车，出租车司机就开始自说自话了，聊东聊西。他们是这个城市半夜的孤魂，永远也找不到自己的出口。<br>接着就开始抱怨：“那些男司机每天下班回家，家里都会做好饭，喜好衣服，把一切都弄好，我们呢？休息的时候<br>还要早起洗衣服做饭，拖地板。永远没有休息的时候。”<br>“其实我还算幸运的了，我载完你去洗车，然后去交接车子之后就可以回家了。<br>我的一个同事就辛苦的多了，好不容易在老家盖起了房子，贷款还没还清，老公就检查出来癌症，<br>平常她的老公也没有对她怎么怎么好，可是却要一起去承担这种事情。看她的样子都老了好多。”<br>她没有讲完我就到目的地了，可是感觉她永远也有讲不完的故事，然后对着不同的人讲着相似的故事。</p>
<p>下车之后12点多了，在这个城市中游荡，此时正是盛宴之后。商厦这时候都已经关门，却依然发出艳丽的霓虹灯。<br>路灯这时候撑起昏黄的小伞，清冷的空气扑面而来。<br>这时候路上已经没有什么人，可以听见脚底与路面的摩擦的声音。呼吸的声音。<br>月亮挂在高远的天空中。<br>此刻仿佛有着黑洞在靠近，将一切都吸引过去，包括光，内心也变得恐惧起来。</p>
<p>静谧一下子被打破，所有的东西都动了起来。一切都开始扭曲。<br>所有的东西都长出了脚，高楼缓慢笨拙的移动着，路灯开始奔跑起来，远方传来响亮的嘶吼声。<br>仿佛一只蚂蚁在人群之中一样，他们走动，巨大的脚掌在空中移动，明与暗不停的交错，我却也无处可躲，<br>我是如此的微小，他们也感受不到我的存在。</p>
<p>在慌乱中我呆滞地站在原地，看着一切。</p>
<p>(2)</p>
<p>达达的马蹄，一匹马在暗黑的玻璃上，在流动的水上飞跃。<br>它停在我的面前，载起我，飞驰而上，<br>流动的城市形成了一个八卦阵的形状。一辆辆车子在其中左突，右冲，可是总是在这个城市中打圈。</p>
<p>是的，他的人生毫无价值，你看，他蜷缩在那个角落中，衣衫褴褛，比一张废纸还不如。</p>
<p>你看那个齿轮，他天生就是一块齿轮吗？<br>你知道齿轮的生产过程马？他们本是一块铁，因为特殊的需要，经过高温溶成铁水，然后浇筑在模版上。</p>
<p>来到镜子面前，仔细的端详着这张脸，这么熟悉，我仔细的看着，仿佛看着一个非常熟悉是字一样，突然间变得非常的陌生，<br>文字好像突然有了形象，而这张脸仿佛逐渐变成了一个符号，没有什么特点，没有美丑，没有颜色，只剩下一个粗劣的线条。<br>另一面镜子就竖在对面，瞬间这张脸被复制了无数遍，</p>
<p>你是谁，你在干什么，你想要什么？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;(一)&lt;/p&gt;
&lt;p&gt;来到这个城市已经十年，时间在指尖上溜过，却什么也不曾留下，一无所有的来，可是比到来变得更加得一无所有，&lt;br&gt;来的时候以为能够在这个城市留下辉煌，可是我是留下来，也把我的卑微也留下。&lt;br&gt;如果我手中有一把剑，我会成为一位剑客，纵横四海，无所畏惧，可是
    
    </summary>
    
    
      <category term="人头马身" scheme="%5Bobject%20Object%5D/tags/%E4%BA%BA%E5%A4%B4%E9%A9%AC%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>深秋</title>
    <link href="%5Bobject%20Object%5D/2016/10/22/last-Fall/"/>
    <id>[object Object]/2016/10/22/last-Fall/</id>
    <published>2016-10-22T09:28:47.000Z</published>
    <updated>2016-10-22T13:18:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>北方的气温已经降了下来，有必要套一件大衣了。<br>南方开始下雨，连门都出不了，不然就要拖着一身的风雨回来了。<br>深秋时节最美，这是生命的大繁华的时刻。<br>不宽的水泥地，青色的矮墙，燃烧的银杏树，点燃金色的光芒，虽是下午，但是前方布满薄雾。显得非常的深远。<br>雨巷还是随处可见，丁香一样的姑娘早已经离去，雨水依然滴答这石板。<br>秋天是一个收获的季节。<br>桔树，葡萄树经过一个夏天的生长，现在人们欣喜的把果子采摘下来，成为了人们口中甜美的美食。</p>
<p>深秋了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;北方的气温已经降了下来，有必要套一件大衣了。&lt;br&gt;南方开始下雨，连门都出不了，不然就要拖着一身的风雨回来了。&lt;br&gt;深秋时节最美，这是生命的大繁华的时刻。&lt;br&gt;不宽的水泥地，青色的矮墙，燃烧的银杏树，点燃金色的光芒，虽是下午，但是前方布满薄雾。显得非常的深远。&lt;br&gt;雨
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自测网关安全性</title>
    <link href="%5Bobject%20Object%5D/2016/10/20/gateway-s-safe/"/>
    <id>[object Object]/2016/10/20/gateway-s-safe/</id>
    <published>2016-10-20T09:28:16.000Z</published>
    <updated>2016-10-20T09:35:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>网关的主要作用是转换原B/S，C/S系统的协议，将原来未加密的协议转换成加密的协议。<br>在这里网关将未加密的HTTP协议或者TCP协议转换成SSL协议。<br>任何一个增加的系统都会增加安全性的问题，作为一款加密产品，那么它更应该注重自生的安全性问题。</p>
<ul>
<li>IP和端口扫描(nmap，netcat)</li>
<li>对访问用户压测，看看有大量用户访问时是否会断开连接(burpsuit, ab, loadrunner)</li>
<li>查看每一个连接中的关键数据是否加密</li>
<li>传输的数据是否加密</li>
<li>对文件上传和下载是否满足用户权限的要求，是否保护</li>
<li>对shell和sql是否防止注入</li>
<li>对网关的系统和服务器进行安全性扫描</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网关的主要作用是转换原B/S，C/S系统的协议，将原来未加密的协议转换成加密的协议。&lt;br&gt;在这里网关将未加密的HTTP协议或者TCP协议转换成SSL协议。&lt;br&gt;任何一个增加的系统都会增加安全性的问题，作为一款加密产品，那么它更应该注重自生的安全性问题。&lt;/p&gt;
&lt;ul&gt;
    
    </summary>
    
    
      <category term="Tech" scheme="%5Bobject%20Object%5D/tags/Tech/"/>
    
  </entry>
  
</feed>
