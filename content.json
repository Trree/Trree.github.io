{"meta":{"title":"Tree","subtitle":"追寻一切未知","description":"Linux服务的开发","author":"Feilong","url":"[object Object]"},"pages":[{"title":"tags","date":"2017-07-29T08:02:44.000Z","updated":"2017-07-29T08:02:44.000Z","comments":true,"path":"tags/index.html","permalink":"[object Object]/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"begin ambiguous","slug":"begin-ambiguous","date":"2017-08-20T06:14:33.000Z","updated":"2017-08-20T06:22:33.000Z","comments":true,"path":"2017/08/20/begin-ambiguous/","link":"","permalink":"[object Object]/2017/08/20/begin-ambiguous/","excerpt":"","text":"begin.cc #include &lt;boost/range.hpp&gt; using boost::begin; using boost::end; int main() { std::string cipher_name(“aaa&quot;); int num_items1 = std::count(begin(cipher_name), end(cipher_name), &#39;-&#39;); return 0; } if we don’t use c++11, then g++ -g begin.cc -o aa it ok. But if we use c++11, in the vs2015 or g++4.8 g++ -g -std=c++ begin.cc -o aa then we will get error: call of overloaded &#39;begin(std::string&amp;)&#39; is ambiguous int num_items1 = std::count(begin(cipher_name), end(cipher_name), &#39;-&#39;); it is nonsense, we had used namespace boost::begin in the header, why it also use std::begin。we write this code to compatible boost and std;and this code is very simple ,we don’t use extra things. so we should read the api document.In the std::being, we notes that In addition to being included in &lt;iterator&gt;, std::begin is guaranteed to become available if any of the following headers are included: &lt;array&gt;, &lt;deque&gt;, &lt;forward_list&gt;, &lt;list&gt;, &lt;map&gt;, &lt;regex&gt;, &lt;set&gt;, &lt;string&gt;, &lt;unordered_map&gt;, &lt;unordered_set&gt;, and &lt;vector&gt;. so if we use std::string, c++11 use std::begin implicitly.How can we solve this problem.we can use __cplusplus to solve this problem. #if __cplusplus &gt;= 199711L #include &lt;iterator&gt; using std::begin; using std::end; #else #include &lt;boost/range.hpp&gt; using boost::begin; using boost::end; #endif you can use __cplusplus distinguish c++11.","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"[object Object]/tags/c/"}]},{"title":"如何获取有价值的信息","slug":"read","date":"2017-08-20T06:09:04.000Z","updated":"2017-08-20T06:13:59.000Z","comments":true,"path":"2017/08/20/read/","link":"","permalink":"[object Object]/2017/08/20/read/","excerpt":"","text":"在这个资讯泛滥的时代，获取对自己有用的信息犹如沙里淘金。我们如此容易沉浸在打发时间的中愉快中度日。在片刻两手空空的时候是否想到哪些东西是我们真正需要的呢？ 最开始的时候是纸媒+新闻联播的时候，那时候的人们没有选择的余地，因为可以选择的东西是在是太少了。后来到了门户资讯时代，可是现在我们已经对引人眼球的标题早已经麻木。对所有的东西都已经见怪不怪了。现在的微博微信公众号占据了我们大量的时间。 这些东西或许能够激起一时的阅读欲望，可是慢慢熟悉了这些刺激的套路之后，慢慢陷入了一种知识荒漠的时候。 其实综上，我们发现获取知识的方式都是被动型的，我们被动的接受着别人给予的一切，他们永远比我们还要清楚我们的弱点，精准投放，然后我们接受着原始的刺激，兴奋的刷着一切。 我们现在如何获取自己觉得有价值的东西呢？其实我们只需要转变一下方式，将被动改为主动。即主动去获取自己敢兴趣的东西。具体的实现方式我认为是三个方面：书籍+搜索+订阅 书籍：虽然阅读书籍是最耗时的一件事情，而且现在最值钱的东西就是时间了，那么我们为什么还要花大量时间去看书呢？首先书可以创建一个完整的知识体系，它首先应该是自洽的，而且是可以被证明是正确的。每一个学科都是有一系列前人的总结的入门书籍，进阶书籍，学一门学科就是学它的历史，通过前辈的推荐加上网上的搜索，我们可以很轻易的得到这么一个书单。而且一本书的好坏现在有一种一般性的判断标准，豆瓣+知乎，在阅读这本书之前看看这本书的评分和评价。然后再选择是否开始阅读这本书，虽然这种方法会有一定的缺陷，但是可以排除大量的烂书，毕竟时间才是最重要的。 搜索：google+bing+baidu 订阅：我们需要获取一些及时的消息来不被时代抛弃。最为一名程序员，毕竟需要查看一下时代的发展方向。而且程序员大多提供的是技术博客，很多的博客是独立博客的存在，虽然更新的比较慢，但是都是思考后的结果。将这些博客集合到一起可以节省很多的时间。对于大多数人来说，将自己感兴趣的网站集合到一个软件中，不用在多个之间进行切换。提供RSS订阅的软件非常多，自己可以通过搜索得到。","categories":[],"tags":[{"name":"Think","slug":"Think","permalink":"[object Object]/tags/Think/"}]},{"title":"openvpn简述","slug":"openvpn","date":"2017-07-27T12:06:27.000Z","updated":"2017-07-29T07:48:22.000Z","comments":true,"path":"2017/07/27/openvpn/","link":"","permalink":"[object Object]/2017/07/27/openvpn/","excerpt":"","text":"前置知识TCP/IP网络，IP路由 VPN与OpenVPNVPN是一种实现虚拟专用网的技术。 典型的实现有IPSec，L2TP，PPTP等，各类OS都有相应的支持，开源的轻量级实现有OpenVPN。 OpenVPNOpenVPN实现了一个灵活的VPN，和通过修改协议栈而实现的基于IPSec的VPN相比，OpenVPN有以下的优点： OpenVPN无需对协议栈进行任何修改，无需专门的策略来解决VPN数据穿越NAT的问题，因此可在现有的网络进行规划； OpenVPN使用虚拟网卡和路由进行虚拟网络的构建，配置十分方便； OpenVPN使用SSL协议对虚拟网络提供保护，从而实现“专用”，而SSL提供了丰富灵活的安全特性； OpenVPN的push模式可以最大限度简化客户端配置，服务器和客户端可以不必花费太多的精力来使得两端一致。 OpenVPN实际上是虚拟网卡设备，TCP/IP网络技术，路由技术，SSL结合而成的一个应用，前三者构建了虚拟网络—隧道连接的网络，最后的SSL保证了虚拟网络通信的安全——隧道通信的认证和加密，因此使用OpenVPN的过程基本就是对上述四方面进行配置的过程。 数据流 OpenVPN 协议 OpenVPN连接建立 OpenVPN协议解析-网络结构之外 关键概念虚拟网卡——OpenVPN最重要的概念 虚拟网卡 TUN/TAP 驱动程序设计原理 虚拟网卡可以看作是一个连接协议栈底层和用户态应用程序的一个管道，数据从虚拟网卡流出，进入应用程序，封装后发出，如下图所示： IP路由IP路由在OpenVPN中起着至关重要的作用，数据包之所以能被截获进而被加密，完全靠IP路由 OpenVPN服务端配置实例#执行外部程序的安全等级 script-security 2 #虚拟网卡设备：tun封装三层IP数据报，tap封装二层以太帧，支持非IP协议 dev tap #使用的封装协议：tcp与udp proto udp #SSL握手时的角色 tls-server tls-cipher RC4-MD5 cipher BF-CBC #心跳保活 keepalive 1 5 #模式：p2p-仅两端端点；server-一个server可以被多个client连接 mode server #虚拟IP地址池 server 128.129.0.0 255.255.0.0 #本地侦听地址和端口 local 0.0.0.0 port 6119 #日志等级 verb 4 dh dh1024.pem.dh.conf #配置证书链 ca sslvpn.cer #配置用户证书 cert /kssl/RHVPNS/cfg/pem/cae0c1c4.dbcb1db54387be84651b8edbe753af7dc1b9e88a.pem key /kssl/RHVPNS/cfg/pem/cae0c1c4.dbcb1db54387be84651b8edbe753af7dc1b9e88a.key OpenVPN客户端配置实例script-security 2 dev tap #定义自己的角色为客户端 client proto udp #自己断开时通知服务端，仅在udp协议下有效 explicit-exit-notify #连接服务端的IP地址以及端口 remote 192.168.40.249 6119 #如果SSL握手不成功，便退出 tls-exit resolv-retry infinite #并不bind本地IP地址，由IP路由自动选择 nobind #允许服务端地址漂移（高级） float verb 4 #配置证书链 ca /kssl/VPN/cfg/SSL-DemoCA.cer #配置本地用户证书 pkcs12 psbc.pfx OpenVPN的事件OpenVPN可以在发生某些重要事件时执行外部脚本，对于服务端，典型的事件有： 虚拟网卡启动：只需要在服务端的配置文件中加入up /root/up.sh，即可，一个例子如下： #!/bin/bash route add 1.2.3.4 gw 128.129.0.2 客户端连接：只需要在服务端配置文件中加入client-connect /root/conn.sh，即可，一个例子如下： #!/bin/bash echo “push route 12.12.12.12 255.255.255.255&quot; &gt;&gt;$1 客户端断开：某一个客户端断开的时候，会执行，一个例子如下： #!/bin/bash #有大量环境变量可用，可通过env来查询 name=$(printenv common_name) real_addr=$(printenv trusted_ip) echo $(date) &quot;client $name from $ real_addr disconnect&quot; &gt;&gt; /kssl/RHVPNS/log/conn.log 客户端典型的事件如下： up，down同服务端 服务端推送的路由生效时：在客户端配置中加入route-up “/kssl/VPNC/bin/route-add.sh” 即可 在以上事件发生时，除了使用bash，python，php等脚本之外，还可以使用plugin，一个plugin就是一个so/dll，它初始化时注册感兴趣的事件，事件发生时调用其回调函数。 OpenVPN简介 VPN替代昂贵的专线用以在开放的Internet上实现了一个虚拟的网络，该虚拟网络本身在不安全的真实网络上对数据提供安全保护。 OpenVPN实现了一个灵活的VPN，和通过修改协议栈而实现的基于IPSec的VPN相比，OpenVPN有以下的优点： OpenVPN无需对协议栈进行任何修改，无需专门的策略来解决VPN数据穿越NAT的问题，因此可在现有的网络进行规划； OpenVPN使用虚拟网卡和路由进行虚拟网络的构建，配置十分方便； OpenVPN使用SSL协议对虚拟网络提供保护，从而实现“专用”，而SSL提供了丰富灵活的安全特性； OpenVPN的push模式可以最大限度简化客户端配置，服务器和客户端可以不必花费太多的精力来使得两端一致。 OpenVPN实际上是虚拟网卡设备，TCP/IP网络技术，路由技术，SSL结合而成的一个应用，前三者构建了虚拟网络—隧道连接的网络，最后SSL保证了虚拟网络通信的安全—隧道通信的认证和加密，因此使用OpenVPN的过程基本就是对上述四方面进行配置的过程。 OpenVPN关键配置项 –dev tunX|tapX：配置虚拟网络使用的网卡设备，X是一个数字表示网卡的编号，在Unix/Linux系统中，它是一个字符设备，在Windows中，它是一个设备命名空间中的一个节点，tun设备和tap设备的区别在于出入前者的第三层（IP）数据报，而出入后者的是第二层（以太网）数据帧。 注意：tap设备是二层设备，tun设备为三层设备，此二者各有优劣，简述如下 tap特点: 应用这种设备可以复用任意的三层数据报； 构成一个两路层网络，比如以太网，因此广播数据可以自由跨隧道传输； 无需路由即可进行节点通信； 配置简单，但是缺乏灵活性，IP层的优良特性无法自由应用。 tun特点: 可以应用IP层的所有特性，比如Routing，IP-Qos，IP-fragment/de等，但是只支持IP数据报； 构成三层网络，节点间如不在一个子网要路由； 三层虚拟网络的每个子网下面没有链路层承载（ip数据报直接导出），因此链路层特性无法应用，比如以太网广播无法跨隧道传输，因此此虚拟网络是无法指定网关的。 –dev-type dt：指示虚拟网卡设备的类型，仅仅在—dev参数无法识别设备类型的时候使用。 –dev-node node：任意节点node被指示为虚拟网卡设备，node的路径以及名称可以任意，但是如果不是tunX/tapX的形式，那么必须配置—dev-type参数。 –lladdr hw：为虚拟网卡配置链路层地址。 网络配置参数 –local host：配置本地使用的IP地址，如果不是为了bind，那么可以不配置此参数，OpenVPN会自行处理。 –remote host [port]：用于client端，配置client连接的server的IP或者主机名以及port，该参数可以配置多个用以实现一定的冗余，client则按照配置顺序依次连接server，直到连接成功为止。 –proto p：配置隧道的类型，可以是udp或者tcp，其中tcp必须指明是server还是client，而udp可以不区分server和client，因此p可以为udp，tcp-server，tcp-client。 注意：用tcp还是用udp构建隧道呢？默认是udp。任何有连接的协议在出现丢包时都会要求重发或者自动超时重发，为了避免因对网络带宽的未知或者网络拥塞而丢包从而导致端点重发，tcp实现了慢启动，滑动窗口以及加增承减等机制，不幸的是，以上机制仅可用于分层模型中的一层，在不同层次都实现得如此复杂就可能引起判断叠加从而使得上述机制无法做出最好的判断，比如用tcp建立的隧道，并且上面承载的又是tcp数据，那么一旦出现丢包，最终的端点以及隧道都要重发数据，这就导致了网络流量突然增大，后面的行为很难在短时间给出预测并采取措施。事实上如果隧道本身并不是非用tcp不可，那么最好使用udp，保证连接与否是最终终端的事，而不是隧道的事，如果说最终用户使用tcp，那么他自己就保证了连接，如果他使用udp，那么说明他不在乎是否有连接，因此隧道使用udp，相反隧道使用tcp建立的话，如果最终用户使用tcp已经保证了连接，隧道没必要再多此一举，如果最终用户使用udp，那么隧道的tcp就降低了用户连接的效率，抵消了他使用udp的结果。 –connect-retry n：配置连接重试的次数，仅仅对于—proto参数为tcp-client时有效。 –connect-timeout n：连接重试的间隔。 –auto-proxy： –bind： –nobind： –link-mtu n：配置四层链路的MTU，同时用同样的数值配置设备的MTU。 注意：这个配置可能会引起莫名其妙的问题，就其本质是由于OpenVPN不允许通过隧道的数据被任意分段，即使是IP分片也必须妥善处理，OpenVPN用一种规则的方式来收发socket数据。IP层将数据路由到虚拟网卡前如果发现数据报的长度大于虚拟网卡的MTU，那么就会将数据报分片，如果VPN两端的虚拟网卡的MTU设置不一致，OpenVPN接收socket数据的时候就会产生问题，因为最一般的情况下OpenVPN调用recv/recvfrom的时候，参数中的len总是设置成自己的link-mtu，假设两端H1和H2的link-mtu分别为L1 和L2（L1&gt;L2），H1端发送数据给H2，则数据在H2则会接收不完整，因此势必会产生错误，即使解密收到的数据可能正确，由于数据长度不一致，校验时也会出错，即使在没有校验的情形下，由OpenVPN发送给虚拟网卡的IP数据报也会不完整。因此最好不要配置link-mtu参数，让它默认值好了，如果非要配置，保持两端一致。可以在linux上用strace，tcpdump以及OpenVPN源代码确认以上问题，具体为何这样设计还不清楚。如果在不考虑安全因素（程序输出的意思是防止active attack）可以更合理一些的话，我觉得recv数据时要按照对方的mtu来接收，毕竟recv和send只是一个中间阶段，数据从对端虚拟网卡的字符设备出来后就被send了，然后在本端被recv，之后被write进本端的虚拟网卡字符设备，如果仅仅按照本端的mtu来接收，势必会有问题，就好像在物理层上将数据截断一样。（在隧道的一端ping另一端，如果mtu不一致并且ping包大于mtu的小者的话，一定不同，可是仅仅将两端作为中间隧道的话就不一定了，数据从主机A，经由隧道的起始Ts，到达隧道终点Te，最终到达主机B，如果Ts和Te的mtu中小者都比A和B的mtu的大者大，在不考虑复杂的分段情况下是可以通的）因此，一种“几乎总是正确”的配置方法就是将mtu配置成一个很大的值，要比已知的物理链路的mtu都大，这样一来不会出错，二来可以不必担心两端不一致，三来可以最大限度的发送数据，而不会因为隧道太窄的缘故而降低数据发送速率，如果不理解以上这些或者为了保险起见，还是将mtu留默认比较好。 –tun-mtu：注意事项同上，但是要强调和link-mtu之不同，此二者配置一个即可且只能配置一个，此中之缘由在于其关联性，tun-mtu为虚拟网卡之mtu，而link-mtu则为链路的mtu，其大小相差一个固定长度，二者区别等同于TCP的MSS和物理链路的MTU之区别。 –shaper：该参数对隧道的带宽进行了限制，主要用于建立多个通道时在各个通道进行策略化带宽分配，如果只建立一个通道，也就是说仅仅运行一个OpenVPN实例的话，这个参数就目前版本而言意义不大，因为本身单进程单线程的OpenVPN速度就很慢，再限速更没有意义了。 –txqueuelen：该参数设定虚拟网卡的最大排队包的数量，也就是队列长度，默认为100，对于OpenVPN这样很慢的VPN来说，100就够了，即使你设得再大，用户空间的OpenVPN进程处理不过来还是白搭。 路由参数 –route network [netmask] [gateway] [metric]：增加一条路由。 –max-routes n： –route-gateway gw|’dhcp’： –route-metric m：配置路由的传输开销 –route-delay n [w]：配置路由添加的延迟，这是为了解决一IP地址自动配置的问题，有时候OpenVPN要添加路由了，可是OS还没有准备好，所以要给与一定的延迟。具体来说就是，client和server的连接建立以后，server需要往client端push一些信息，包括虚拟网卡ip地址，子网掩码等必须的信息以及路由等可选信息，client接收到以后需要在本机做相应的配置，比如配置虚拟网卡的ip/子网掩码，添加路由等，并且OpenVPN对虚拟网卡的管理采取了一种懒惰的方式，也就是对于server只有在OpenVPN起来，对于client只有在和server的连接建立的时候才会建立虚拟网卡对象并初始化，这个初始化过程就包括了设置ip地址/子网掩码，这个过程完成之前，添加路由是失败的，因此必须提供一些延迟保证虚拟网卡初始化完毕之后再添加路由。这个选项主要针对某些虚拟网卡驱动设计不友好的系统，比如基于NDIS驱动的windows系统，虚拟网卡的ip地址“看起来”是通过DHCP来分配，而DHCP分配是需要花费时间的，此间添加路由的请求必须等待。 SSL及安全参数 –genkey：生成一个对称密钥，该参数只能单独使用，该对称密钥的生成是为了使OpenVPN两端共享，从而不再使用SSL握手协议进行密钥协商。 –secret file：使用共享的对称密钥。这实际上省去了SSL的握手，用于通信双方确信已拥有绝对保密绝对安全的对称密钥的情况，实际上SSL的握手也是为了这个保证，二者殊途同归，因此问题的难度就在于一端用—genkey生成的密钥如何传输至另一端。这其实就是另一个大问题了，可以用数字信封传过去，甚至可以冒险用明文直接发过去，这些都不是OpenVPN要考虑的。一般地在都是通过scp程序传递的，方便又安全。 –reneg-XXX：这一族参数用来重新协商session key。OpenVPN基于SSL协议，然则其用法另有说法，SSL协议自带认证和加密功能，对于OpenVPN来说此二者是分开的，如果不考虑认证，密钥协商的过程很容易受到中间人攻击，因此不管是基于IPSec这种修改或挂钩协议栈实现的VPN还是OpenVPN都提供了认证机制。OpenVPN使用证书来进行认证，使用DH来进行密钥协商。使用DH而不是别的是由于建立的隧道安全参数要每隔一段时间进行一次重新协商，默认时间为1个小时，而DH的效率很高，它不像RSA产生密钥那么耗时（由于美国出限制或者证书中没有可用于加密的公钥，在SSL握手时就需要临时生成一对RSA密钥），如此在server key exchange message消息中传输的就是DH参数了。 –ca file：CA证书，用以验证对端的用户证书，这个参数可以包含多个证书，也就是一条证书链，在Unix/Linux中可以用cat命令将多个证书追加成一个文件。 –cert file：自己的证书，用于传递给对端以表明自己的身份或者实现其它的准入性验证。 –key file：对应—cert参数的key文件。 –cryptoapicert select-string：用于从Windows的证书Store中获取证书，如此就不再需要—cert和—key参数了，select-string是一个字符串，可以认为是一个查找“键值”，以”名称:值”的形式存在，比如使用颁发给名字是“老李”的个人的证书，那么select-string就是：”SUBJ:老李”。这个参数多数用于key或者证书无法单独导出的环境下，比如一些设备。 参考OpenVPN的使用和配置 openvpn blog","categories":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/categories/Tech/"}],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"Apache 讲解","slug":"apapche-pratice","date":"2017-07-09T03:26:10.000Z","updated":"2017-07-16T07:13:19.000Z","comments":true,"path":"2017/07/09/apapche-pratice/","link":"","permalink":"[object Object]/2017/07/09/apapche-pratice/","excerpt":"","text":"概述简单服务器流程Q1：简述在浏览器中输入 www.baidu.com 之后发生的一系列事情 appendix1：http1.0 vs http1.1 I/O 模型 阻塞式 I/O 模型 非阻塞 I/O 模型 I/O 复用 模型 异步 I/O 模型 UNIX网络编程(卷1)：套接字联网API(第3版) 工作模式 event(多进程多线程) prefork(多进程) worker(多进程多线程) 查看apache的工作模式 /usr/sbin/apachectl -V 内存管理内存管理 核心数据结构 request的关键元素 The most essential part of any request is the request record. In a call to a handler function, this is represented by the request_rec structure passed along with every call that is made. This struct, typically just referred to as r in modules, contains all the information you need for your module to fully process any HTTP request and respond accordingly. Some key elements of the request_recstructure are: r-&gt;handler (char*): Contains the name of the handler the server is currently asking to do the handling of this request r-&gt;method (char*): Contains the HTTP method being used, f.x. GET or POST r-&gt;filename (char*): Contains the translated filename the client is requesting r-&gt;args (char*): Contains the query string of the request, if any r-&gt;headers_in (apr_table_t*): Contains all the headers sent by the client r-&gt;connection (conn_rec*): A record containing information about the current connection r-&gt;user (char*): If the URI requires authentication, this is set to the username provided r-&gt;useragent_ip (char*): The IP address of the client connecting to us r-&gt;pool (apr_pool_t*): The memory pool of this request. We’ll discuss this in the “Memory management“ chapter. 核心数据结构 mod_helloworld 模块讲解modguide Apache: 启动流程 Apache: 连接 / 请求处理流程 apxs -n helloworld -g Defining a module #include \"httpd.h\" #include \"http_config.h\" #include \"http_protocol.h\" #include \"ap_config.h\" /* The sample content handler */ static int helloworld_handler(request_rec *r) { if (strcmp(r->handler, \"helloworld\")) { return DECLINED; } r->content_type = \"text/html\"; if (!r->header_only) ap_rputs(\"The sample page from mod_helloworld.c\\n\", r); return OK; } static void helloworld_register_hooks(apr_pool_t *p) { ap_hook_handler(helloworld_handler, NULL, NULL, APR_HOOK_MIDDLE); } /* Dispatch list for API hooks */ /* 标记服务器能够加载的模块名 */ /* 为模块配置设置一个命名空间 */ module AP_MODULE_DECLARE_DATA helloworld_module = { STANDARD20_MODULE_STUFF, NULL, /* create per-dir config structures */ NULL, /* merge per-dir config structures */ NULL, /* create per-server config structures */ NULL, /* merge per-server config structures */ helloworld_directives, /* table of config file commands */ helloworld_register_hooks /* register hooks */ }; 指令typedef struct { int enabled; /* Enable or disable our module */ const char *path; /* Some path to...something */ int typeOfAction; /* 1 means action A, 2 means action B and so on */ } example_config; static const command_rec helloworld_directives[] = { AP_INIT_TAKE1(\"exampleEnabled\", example_set_enabled, NULL, RSRC_CONF, \"Enable or disable mod_example\"), AP_INIT_TAKE1(\"examplePath\", example_set_path, NULL, RSRC_CONF, \"The path to whatever\"), AP_INIT_TAKE2(\"exampleAction\", example_set_action, NULL, RSRC_CONF, \"Special action value!\"), { NULL } }; 配置的作用域 OR_ALL 所有的地方使用 ACCESS_CONF：允许指令出现这Directiory Location 区间以内的顶级命令区，一般是用来设置特定文的指令控制 RSRC_CONF: 允许指令出现在 Directiory Location 区间以外的顶级命令区 配置段合并配置段会按非常特别的顺序依次生效，由于这会对配置指令的处理结果产生重大影响，因此理解它的流程非常重要。 合并的顺序是： &lt;Directory&gt;(除了正则表达式)和.htaccess同时处理；(如果允许的话，.htaccess的设置会覆盖&lt;Directory&gt;的设置) &lt;DirectoryMatch&gt;(和&lt;Directory ~&gt;) &lt;Files&gt;和&lt;FilesMatch&gt;同时处理 &lt;Location&gt;和&lt;LocationMatch&gt;同时处理 除了&lt;Directory&gt;，每个组都按它们在配置文件中出现的顺序被依次处理，而&lt;Directory&gt;(上面的第1组)，会按字典顺序由短到长被依次处理。例如：&lt;Directory /var/web/dir&gt;会先于&lt;Directory /var/web/dir/subdir&gt;被处理。如果有多个指向同一个目录的&lt;Directory&gt;段，则按它们在配置文件中的顺序被依次处理。用Include指令包含进来的配置被视为按原样插入到Include指令的位置。 位于&lt;VirtualHost&gt;容器中的配置段在外部对应的段处理完毕以后再处理，这样就允许虚拟主机覆盖主服务器的设置。 代码示例 void *create_dir_conf(apr_pool_t *pool, char *context) { context = context ? context : \"(undefined context)\"; example_config *cfg = apr_pcalloc(pool, sizeof(example_config)); if(cfg) { /* Set some default values */ strcpy(cfg->context, context); cfg->enabled = 0; cfg->path = \"/foo/bar\"; cfg->typeOfAction = 0x11; } return cfg; } void *merge_dir_conf(apr_pool_t *pool, void *BASE, void *ADD) { example_config *base = (example_config *) BASE ; /* This is what was set in the parent context */ example_config *add = (example_config *) ADD ; /* This is what is set in the new context */ example_config *conf = (example_config *) create_dir_conf(pool, \"Merged configuration\"); /* This will be the merged configuration */ /* Merge configurations */ conf->enabled = ( add->enabled == 0 ) ? base->enabled : add->enabled ; conf->typeOfAction = add->typeOfAction ? add->typeOfAction : base->typeOfAction; strcpy(conf->path, strlen(add->path) ? add->path : base->path); return conf ; } module AP_MODULE_DECLARE_DATA example_module = { STANDARD20_MODULE_STUFF, create_dir_conf, /* Per-directory configuration handler */ merge_dir_conf, /* Merge handler for per-directory configurations */ NULL, /* Per-server configuration handler */ NULL, /* Merge handler for per-server configurations */ directives, /* Any directives we may have for httpd */ register_hooks /* Our hook registering function */ }; hook 钩子 钩子的处理 /*在这个钩子处按照顺序运行所有的被注册函数*/ AP_IMPLEMENT_HOOK_VOID(do_something, (request_rec *r, int n), (r, n)) /*在这个钩子处运行所有的被注册函数直到返回了一个不是DECLINED的值*/ AP_IMPLEMENT_HOOK_RUN_FIRST(int, do_something, (request_rec *r, int n), (r, n), DECLINED) /*运行所有的函数直到或者除非返回一个错误*/ AP_IMPLEMENT_HOOK_RUN_ALL(int, do_something, (request_rec *r, int n), (r, n), OK, DECLINED) 其它有用的钩子 Hooking into the request handling phase is but one of many hooks that you can create. Some other ways of hooking are: ap_hook_child_init: Place a hook that executes when a child process is spawned (commonly used for initializing modules after the server has forked) ap_hook_pre_config: Place a hook that executes before any configuration data has been read (very early hook) ap_hook_post_config: Place a hook that executes after configuration has been parsed, but before the server has forked ap_hook_translate_name: Place a hook that executes when a URI needs to be translated into a filename on the server (think mod_rewrite) ap_hook_quick_handler: Similar to ap_hook_handler, except it is run before any other request hooks (translation, auth, fixups etc) ap_hook_log_transaction: Place a hook that executes when the server is about to add a log entry of the current request ​ 代码调试apache调试","categories":[],"tags":[{"name":"Apache","slug":"Apache","permalink":"[object Object]/tags/Apache/"}]},{"title":"restful 接口设计","slug":"restful","date":"2017-06-09T10:20:03.000Z","updated":"2017-07-13T01:20:55.000Z","comments":true,"path":"2017/06/09/restful/","link":"","permalink":"[object Object]/2017/06/09/restful/","excerpt":"","text":"最近在工作中需要实现一个跨平台，易实现，方便调试排错的接口。经过考虑之后，发现restful接口是非常合适的。 接口的实现是基于c++的boost的。所以有两个非常重要的boost库需要介绍一下。 首先我们需要想想我们需要怎样的借口调用方式，健壮的，易扩展的。 RequestHandler requesthandler; requesthandler.set_handler(&quot;sessions&quot;) .get(boost::bind(&amp;handle_sessions_get_method, _1, _2)) .post(boost::bind(&amp;handle_sessions_post_method, _1, _2, boost::ref(vm))) .put(boost::bind(&amp;handle_sessions_put_method, _1, _2)) .del(boost::bind(&amp;handle_sessions_delete_method, _1, _2)); 我们在这个接口中注册请求处理函数，分别处理 get，post，put，delete请求。 Q1：为什么所有的method请求是连接在一起的？我们需要保持source的唯一性，一个source只能被声明一次， /* -&gt; 表示 key-&gt;value 的数据结构 */ source: sessions action: get ,post, put, del callback: handle_sessions_*_method ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++ | get -&gt; handle_sessions_get_method | | sessions | ---&gt; | post -&gt; handle_sessions_get_method | +++++++++++++ | put -&gt; handle_sessions_put_method | | del -&gt; handle_sessions_delete_method | ++++++++++++++++++++++++++++++++++++++++++++ 整个的调用就是两个 key-&gt; value 的形式 boost::functon typedef std::function&lt;void(response &amp;, const request &amp;)&gt; served_req_handler; boost::function 的boost提供的一个回调函数。","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"背诵","slug":"recitation","date":"2017-06-04T15:26:07.000Z","updated":"2017-06-04T15:39:51.000Z","comments":true,"path":"2017/06/04/recitation/","link":"","permalink":"[object Object]/2017/06/04/recitation/","excerpt":"","text":"这个周末都在准备周一需要背诵的材料。仔细想想，我花了两天的准备时间，自己真正花在背诵的时间其实很少很少。究其原因，是大部分的时间都不再状态，什么叫不在状态，就是你想背诵的时候，脑袋里面总是有其它的挥之不去的东西。其实对需要背诵的材料是非常非常的排斥，在内心里面不愿意去背诵它。背诵的过程也不像敲代码一样有明显的奖励过程。会让自己非常的兴奋。背诵的过程是非常的痛苦与平淡。像是小和尚念经，有口无心一样。 现在想想，你花了两天时间都在准备这个，其实这是一个非常大的误区。背诵是不可能百分百在状态的。人在一天中不同的状态适合处理不同的事务。就像早晨是适合背诵东西的，因为此刻你的心思无杂念。晚上也是适合的，因为此刻是比较安静的。但是上午或者下午对于我却是不太适合，我是逻辑型思考，所有的东西需要依靠逻辑来串联到一起，就像一个哈希表一样。 说的这么多，其实想要表达的是，不要太强求自己，合理规划时间，在对的时间做对的事情，在合适的时间做合适的事情。","categories":[],"tags":[{"name":"Think","slug":"Think","permalink":"[object Object]/tags/Think/"}]},{"title":"早班地铁的爱情","slug":"subway","date":"2017-06-03T02:20:08.000Z","updated":"2017-06-03T12:20:20.000Z","comments":true,"path":"2017/06/03/subway/","link":"","permalink":"[object Object]/2017/06/03/subway/","excerpt":"","text":"王二此刻就在早班的地铁上面，不要问为什么他此刻在早班的地铁上，因为他住在居民区中，而公司要穿过整个城市才能到达，不要问为什么他没有在在公司附近，也不要问他为什么住的地方去公司要穿过整个城市。 他从来没有思考过，因为这是一切自然而然的选择。因为住的地方便宜，上一家公司辞退他之后，这是唯一一家要他的公司。而这家公司刚好就在城市的另一头。好像所有的事情就是这么的巧合。 这是一座号称魔都的城市，你能够想象一个小蜂窝吗？就是一个蜂窝的感觉，你永远不知道你里面钻出多少只蜜蜂，又钻进来多少只蚂蚁，你只能在捅掉这个蜂窝的时候，根据你的恐惧程度逃跑的速度来判断有多少蜜蜂来。所以你不要低估魔都的魔力。 说到蜂窝，不得不提它那六边形蜂房，在数学上面，六边形结构可以在一定体积里，能用最少的材料去建造一個最宽坦的巢室。而且节省材料。再从它们采摘的花粉，投以酿造的蜂蜜，按照这种方式，你养多少的工蜂都不要紧来。唯一感到遗憾都是一旦工蜂无法采集蜂蜜，它们都死期就到来了。但是我想它们非常快乐的，因为我从小就知道劳动是使人快乐的。王二小的时候是非常淘气的，或许是嫉妒蜜蜂总是有事情做，而自己总是无所事事的，所以他见一个就捅一个，然后拔腿就跑，大多数的时候他都是成功的，反而是有一次他在无意之中碰到一个马蜂窝，在毫无防备的情况的变成了小胖子。 都说现在世界上最美妙都事情就是想入非非了。你可以想象任何都东西，江上清风，山间明月，闭上眼镜，你就处在另一个世界了。小隐隐于野，中隐隐于市，大隐隐于朝。现在大隐隐于地铁了。你埋在地铁中。王二正在想着自己已经成为大隐者都时候，手机冷不丁的正中砸向王二的脑袋，一下子把他从江湖之远，拉向地铁之高。 关于地铁，可能跟你现在想象的不太一样，其实是可以理解的。你想想，如果你要最大程度利用地铁里面的空间，你会怎么做呢？是的，可能你已经想到的，顶上也是可以站人的。既然你已经想到地铁底部科研站人，那么你肯定也想到了，只要有顶的地方就可以正常走动了。 关于这一点，人们早就想到了，如果所以你看到的顶部都可以走都话，这个世界瞬间就可以增大两边或者更多都生存空间。其实这是一个非常简单都道理，但是人们就这样的活着，因为这一切都很正常啊，所以人都是这么过来的。就像活在厕所中的蛆一样，从出生的第一眼就是在这里。所以的一切都是合情合理的，没有什么不对，你看过在天空中飞翔的蛆吗？那是不可能的。 一天一个教授在人挤人的地铁中想入非非，为什么顶上不可以站人呢？这又是一项想入非非的奇迹，这真实灵感的发源地。这位教授当时正在为科研申请项目头疼，当他为这个荒唐的想法感到震惊的时候，死猪不拍开水烫，为什么不试一下呢？然后这个伟大的项目在莫名其妙中就获得了科研经费。 但是这个伟大的想法扼杀了另一个伟大的想法，因为手机砸到了王二的头上。把这个伟大的想入非非就一下子砸没了。这其实算是一个bug，在正常流的时候，在顶上的人和他有关联的东西重力方向是一致的。也就是说，你站在顶上，东西掉下去，是朝这顶上去的。你站在地上，你东西是朝向地上的。这种bug存在的机率是十万之一。有人统计过，这个世界上的人一见钟情的概率也是十万之一。如果你被你顶上的人砸中的时候，这是决定命运的时刻，不是闹着玩的。所以你出门的时候要梳妆打扮好。命运之门就存在于bug之中。 这一刻，王二却异常紧张起来。因为他出门的时候从没有想到今天会被手机砸到，就像牛顿从不能预测那天被苹果砸到，然后变成了世界上最伟大的物理学家之一一样。命运之门就这么不经意到来。 后来有朋友问他被砸那一刻的感想，他那时候喝了一点酒，于是随口就说：那时候我非常的担心，担心如果同样是一个男的怎么办，如果已经是阿姨奶奶了怎么办，如果缺胳膊少腿怎么办，甚至他还想到此刻地球毁灭了要怎么办，所以他就在那里呆立了一秒钟，脑袋了翻江倒海，从古至今穿越了几万年，想到了这个世界上的所有的可能。然后在向上望的一瞬间，我仿佛又向前穿越了一百年，想到了与顶上的人的所有的可能。事实就是这样，在那一刻，我遍历了世界上的所以可能。然后遇到了她。","categories":[],"tags":[{"name":"王小波门下走狗","slug":"王小波门下走狗","permalink":"[object Object]/tags/王小波门下走狗/"}]},{"title":"无序","slug":"longway","date":"2017-05-30T09:25:42.000Z","updated":"2017-06-03T02:16:48.000Z","comments":true,"path":"2017/05/30/longway/","link":"","permalink":"[object Object]/2017/05/30/longway/","excerpt":"","text":"你装饰了别人的梦明月装饰了你的窗子，你站在桥上看风景，看风景人在楼上看你。","categories":[],"tags":[{"name":"一个程序员都日常","slug":"一个程序员都日常","permalink":"[object Object]/tags/一个程序员都日常/"}]},{"title":"消失的五月","slug":"disMay","date":"2017-05-28T11:04:21.000Z","updated":"2017-05-28T12:16:01.000Z","comments":true,"path":"2017/05/28/disMay/","link":"","permalink":"[object Object]/2017/05/28/disMay/","excerpt":"","text":"五月好像一瞬间就过去了，在中间没有留下任何的痕迹。生活仿佛没有波澜的心跳线。火车穿过悠长的隧道。窗外失去了风景。一切都在轨道上面。","categories":[],"tags":[{"name":"一个程序员的日常","slug":"一个程序员的日常","permalink":"[object Object]/tags/一个程序员的日常/"}]},{"title":"Apache 压力测试后的大量本地连接","slug":"20170520","date":"2017-05-20T05:32:10.000Z","updated":"2017-05-28T12:06:33.000Z","comments":true,"path":"2017/05/20/20170520/","link":"","permalink":"[object Object]/2017/05/20/20170520/","excerpt":"在对Apache（prefork多进程模式）进行压力测试对时候，发现一旦停止压力测试对时候。会出现非常多的本地连接","text":"在对Apache（prefork多进程模式）进行压力测试对时候，发现一旦停止压力测试对时候。会出现非常多的本地连接 背景在对Apache（prefork多进程模式）进行压力测试对时候，客户端IP：192.168.41.96网关IP和端口; 0.0.0.0:447发现一旦停止压力测试对时候。使用 netstat -an | grep 127会出现非常多的 127.0.0.1:447 连接 tcp 0 0 127.0.0.1:38984 127.0.0.1:447 TIME_WAIT tcp 0 0 127.0.0.1:38994 127.0.0.1:447 TIME_WAIT 查看的时候连接都已经是 TIME_WAIT 的状态，无法查看它是通过哪些进程查看它建立连接。我们怀疑这些连接可能对性能会有影响。所以对这个问题进行了排查。 问题解决因为所有的127.0.0.1的端口都与447端口断开连接，又因为这些无法有效都用gdb调试。所以使用 strace 的方式跟踪进程。 strace -p 683 -o filename_childpidstrace -p 899 -o filename_masterpid filename_childpid 是在压力测试的时候临时创建出来的子进程filename_masterpid 是Apache的主进程 在压力测试时候出现的子进程中可以看到 accept(3, {sa_family=AF_INET, sin_port=htons(36448), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, [16]) = 6 getsockname(6, {sa_family=AF_INET, sin_port=htons(447), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, [16]) = 0 发现这个子进程是accept了连接。但是这些环回地址是如何产生的？ 查看主进程的 strace 文件 waitpid(-1, 0xbffffa18, WNOHANG|WUNTRACED) = 0 select(0, NULL, NULL, NULL, {1, 0}) = 0 (Timeout) write(5, &quot;!&quot;, 1) = 1 socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 9 fcntl64(9, F_GETFL) = 0x2 (flags O_RDWR) fcntl64(9, F_SETFL, O_RDWR|O_NONBLOCK) = 0 connect(9, {sa_family=AF_INET, sin_port=htons(447), sin_addr=inet_addr(&quot;0.0.0.0&quot;)}, 16) = -1 EINPROGRESS (Operation now in progress) poll([{fd=9, events=POLLOUT, revents=POLLOUT}], 1, 3000) = 1 getsockopt(9, SOL_SOCKET, SO_ERROR, [0], [4]) = 0 close(9) = 0 --- SIGCHLD (Child exited) @ 0 (0) --- 从这里发现Apache的主进程发了connect连接，然后自己断开连接。但是为什么回出现这种情况呢？需要进一步查看代码查找原因。 原因压力测试的时候起了非常多的子进程。但是压力测试之后不需要那么多的进程。此时临时建立的子进程都阻塞在select上面。Apache采用都策略就是主进程与阻塞都子进程建立连接，然后关闭连接，所以看到都现象如上。","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"搬家","slug":"20170506","date":"2017-05-06T09:21:59.000Z","updated":"2017-05-28T12:19:01.000Z","comments":true,"path":"2017/05/06/20170506/","link":"","permalink":"[object Object]/2017/05/06/20170506/","excerpt":"最近搬了新的住处，忽然不明白自己为什么在那里住了2年。","text":"最近搬了新的住处，忽然不明白自己为什么在那里住了2年。 最近搬了新的住处，在那个地方也住了两年，现在回想一下，为什么自己会忍受那样的住了2年，我为什么要这么说呢？因为那时候刚来上海，所以对生活对要求也不是很高，是跟朋友合租的，地理位置挺方便的，而且价格也挺合理，造成的结果就是房子比较老，所以一切配套的都是老家具。因为对这个地方最初对定位就是睡觉。所以满足生活的基本要求就满足了。就这样度过了两年。 现在搬到公司附近，有了属于自己的独立的空间。而且家具都是比较新的。这一切突然激发了自己的装饰欲望。 于是在地板上铺好地毯。买了自己一直想种的花。 买了梵高的星空，买了花瓶。买了衣架，买了真空袋把一切都收拾的整整齐齐。就连常年治不好的叠被子也因为不和谐而变得自然。 一直知道自己需要什么，可是在老的住处，看着那些陈旧的老东西，所有都还是老样子，没有改变。 这一切都从我拥有了一双象牙筷子说起。","categories":[],"tags":[{"name":"Think","slug":"Think","permalink":"[object Object]/tags/Think/"}]},{"title":"系统内存不足","slug":"outOfMemory","date":"2017-04-27T02:22:15.000Z","updated":"2017-05-28T12:07:16.000Z","comments":true,"path":"2017/04/27/outOfMemory/","link":"","permalink":"[object Object]/2017/04/27/outOfMemory/","excerpt":"有时候我们会面临一些非常情况的现象，没有异常的情况下进程无缘无故的退出，无法写如日志文件。非常奇怪的错误抛出在终端。","text":"有时候我们会面临一些非常情况的现象，没有异常的情况下进程无缘无故的退出，无法写如日志文件。非常奇怪的错误抛出在终端。 现象及分析有时候我们会面临一些非常情况的现象，没有异常的情况下进程无缘无故的退出，无法写如日志文件。非常奇怪的错误抛出在终端。 这个时候就需要查看一下系统日志 kern.log 了。 MAIN kernel: [17832.300370] [&lt;c1090380&gt;] ? oom_kill_process+0x60/0x201 MAIN kernel: [17832.300408] [&lt;c10908fd&gt;] ? __out_of_memory+0xf4/0x107 MAIN kernel: [17832.300445] [&lt;c109096a&gt;] ? out_of_memory+0x5a/0x7c MAIN kernel: [17832.300482] [&lt;c109322c&gt;] ? __alloc_pages_nodemask+0x3ef/0x4d9 MAIN kernel: [17832.300522] [&lt;c109460d&gt;] ? __do_page_cache_readahead+0x98/0x16b MAIN kernel: [17832.300562] [&lt;c10946f4&gt;] ? ra_submit+0x14/0x18 MAIN kernel: [17832.300597] [&lt;c108ec9a&gt;] ? filemap_fault+0x16d/0x2e6 MAIN kernel: [17832.300634] [&lt;c10a0c9a&gt;] ? __do_fault+0x53/0x3fb MAIN kernel: [17832.300670] [&lt;c10a2f56&gt;] ? handle_mm_fault+0x4d1/0xa22 MAIN kernel: [17832.300708] [&lt;c1144ae3&gt;] ? copy_to_user+0x29/0xf8 MAIN kernel: [17832.300745] [&lt;c10c6b9a&gt;] ? poll_select_copy_remaining+0xbd/0xd9 MAIN kernel: [17832.300785] [&lt;c12830a8&gt;] ? do_page_fault+0x2f1/0x307 MAIN kernel: [17832.300822] [&lt;c1282db7&gt;] ? do_page_fault+0x0/0x307 MAIN kernel: [17832.300857] [&lt;c12815e3&gt;] ? error_code+0x73/0x78 这个时候我们可以发现内存已经不足了。Linux的保护机制在杀内存消耗大的进程。所以会有进程无缘无故的推出。有一些日志是先写到buffer的内存中，然后再调用日志接口把内存中的日志刷到文件中。此时内存已经不足了，所以内存中已经写不进去了。最终我们看到的现象就是写不到文件中。 解决办法内存确实不足最简单的办法就是直接使用 top 工具。使用Memory usage的排序方式，实时查看进程的内存占用情况。查看哪个服务占用了非常大的内存空间。检查一下为什么占用的内存空间非常大。是不是真的需要。 内存泄漏使用 valgrind 的工具运行程序检测内存释放出现泄漏。","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"TCP 握手","slug":"tcp-handshark","date":"2017-03-28T13:44:05.000Z","updated":"2017-05-28T12:19:52.000Z","comments":true,"path":"2017/03/28/tcp-handshark/","link":"","permalink":"[object Object]/2017/03/28/tcp-handshark/","excerpt":"tcp 报头的各个字段的作用想象一下自己去设计一个TCP协议，最中的是保证可靠性。因为每个报文都是要包含这些字段，所以你要怎么保证它的简洁性，不浪费资源。","text":"tcp 报头的各个字段的作用想象一下自己去设计一个TCP协议，最中的是保证可靠性。因为每个报文都是要包含这些字段，所以你要怎么保证它的简洁性，不浪费资源。 source port: 源端口 destination port: 目标端口 sequence number: 序号，每一个TCP报文段都会有一个序列，序列号字段段值其实是本报文段所发送段第一个字节的序号，通过序号来确保服务的可靠性和有序性。 ack number:确认号 Data offset:数据偏移 Reserved:保留字段 URG(urgent)：紧急指针 ACK ：确认字段 PSH：推送字段 RST：复位字段 SYN：同步字段 FIN：终止字段 Windows size：窗口大小 checksum：检验和 Urgent pointer：紧急指针 options：选项 tcp 三次握手为什么tcp握手需要三次？这个保证了什么东西？ 客户端发送一个 SYN 给服务端。 服务端返回一个ack和syn给客户端确认。 客户端在返回一个ack确认。tcp连接建立。 如果只有两次握手会怎样？客户端发送了一个连接请求的SYN，但是由于网络问题，以至这个连接释放之后才到达服务端，这时候服务器发送 ack 和 syn 给客户端。如果此时就建立连接，由于客户端已经废弃了这个 SYN，所以这个连接客户端什么都不会发送，白白浪费了资源。 DDoS攻击的也有相似的原理 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 tcp 四次挥手 客户端发送一个 FIN 给服务端 服务端发送一个ACK 确定 服务端再发送一个 FIN 接收服务端的连接 客户端发送 ACK 确定后关闭连接 半连接的时候是怎么处理的？为什么要四次握手？time_wait 的作用是什么？危害是什么？ tcp 连接是全双工的，所以一边发送FIN，都需要另一边 ACK 确定。","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"apache多种debug调试方式","slug":"apache-debug","date":"2017-03-22T12:02:01.000Z","updated":"2017-03-22T12:20:05.000Z","comments":true,"path":"2017/03/22/apache-debug/","link":"","permalink":"[object Object]/2017/03/22/apache-debug/","excerpt":"","text":"将正在测试的机器上都打开 coredump，等待重现 在linux系统中执行 ulimit -c unlimited 配置文件中添加 CoreDumpDirectory directory 尝试 valgrind 追踪内存错误 valgrind –tool=memcheck –leak-check=yes –show-reachable=yes –error-limit=no apache strace 调试 strace -f -p pid 尝试用 gdb 启动，等待重现 使用gdb启动服务，直接run，等待进程崩溃 apache信号调试 gdb attach进主线程或者需要的线程 breakpoints continue 访问服务或者发信号 gdb接收信号，然后continue 调试","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"水墨画的扩展","slug":"wash-painting","date":"2017-02-15T01:02:05.000Z","updated":"2017-02-15T13:24:22.000Z","comments":true,"path":"2017/02/15/wash-painting/","link":"","permalink":"[object Object]/2017/02/15/wash-painting/","excerpt":"","text":"高与远 水墨画的山水图的结构是非常紧凑的,仿佛有人在极目远望，所有的东西都压缩在一起，视线越远，山峰就变得越高。 层次 水墨虽然都是黑色的，但是浓与淡将空间区分开来，在表现早晨的水雾的时候，效果尤其明显。一些清晰可见，一些若隐若现。 维度 将这些山水画45度角摆放的时候，会产生一种奇艺的效果，仿佛二维的图形有了三维的效果。山水变得立体起来。 时间 仿佛整个世界凝聚于这个瞬间，这个瞬间的所有变化在意想不到的瞬间出现，然后凝聚。","categories":[],"tags":[{"name":"Think","slug":"Think","permalink":"[object Object]/tags/Think/"}]},{"title":"thread","slug":"thread","date":"2017-02-12T06:57:05.000Z","updated":"2017-05-28T12:20:37.000Z","comments":true,"path":"2017/02/12/thread/","link":"","permalink":"[object Object]/2017/02/12/thread/","excerpt":"只要我时间了，我就把这本书看完。 如果我有很多钱，我就要去全世界旅游。","text":"只要我时间了，我就把这本书看完。 如果我有很多钱，我就要去全世界旅游。 总是喜欢信誓旦旦的对别人说着一些话，不知道最后多少人达成了目标。就像小时候想要的那个模型。现在可以轻而易举的买下小时候的想要的任何东西。可是突然失去了对这件事情的乐趣。时间与环境的变化，那么事情本事早就失去了它原本的意义。 太多时候总喜欢用如果只要达到什么条件，那么我就要做什么。喜欢把生活一步一步的规划，达到一个目标之后，才开始进行下一步。如果有一步陷入了困境，那么就一直阻塞在那一步。 计算机人员在解释多核的时候，喜欢用一个人在多项任务之间切换得够快，那么像是在同时处理多件事情一样。但是我们不能像孙悟空或者技术总监一样分身。分配人员同时处理不同的事情。 但是可以像线程一样。在保证主线程正常运行的时候，使用多线程的方法，从现在慢慢就开始做自己喜欢的事情。但是也要保证线程安全。 refer: thread","categories":[],"tags":[{"name":"Tech, Think","slug":"Tech-Think","permalink":"[object Object]/tags/Tech-Think/"}]},{"title":"问问题","slug":"ask-question","date":"2017-02-08T10:23:00.000Z","updated":"2017-02-08T10:23:00.000Z","comments":true,"path":"2017/02/08/ask-question/","link":"","permalink":"[object Object]/2017/02/08/ask-question/","excerpt":"","text":"在问问题之前不需要问在不在，一般上班时间并且头像是亮着的话人是在的。 这个项目的背景是怎样的？问题是在什么时候产生的，是在部署的时候还是网关在运行的时候产生的，如果是网关在运行的时候产生的，那么在之前有没有进行过什么操作。需要能够描述问题产生原因。而不是只是描述一个结果。 问题能否重现，重现的方法是什么，如果不能重现，说明不能重现的理由。（在自己电脑中使用虚拟机搭建网关的环境） 提供网关的版本号，升级包记录等相关信息。 需要时要能够使用tcpdump到网关后台抓包。平时需要学会使用tcpdump和wireshare等简单的工具。 简单的学会一些linux的命令行，vim等操作。 问问题之前先参考wiki或者FAQ上是否存在类似的问题。 学会怎么问问题。提供以上信息，并且能够一次性把问题描述清楚。","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"Apache内存管理","slug":"apache-pool","date":"2017-02-06T11:47:33.000Z","updated":"2017-05-28T12:21:12.000Z","comments":true,"path":"2017/02/06/apache-pool/","link":"","permalink":"[object Object]/2017/02/06/apache-pool/","excerpt":"Apache 提供了自己的内存和资源管理方式，称作内存池，内存池在apache中任何一个阶段被使用，所以也被外部模块使用。内存池可以管理内存，Sockets 和进程等服务系统所有的资源。","text":"Apache 提供了自己的内存和资源管理方式，称作内存池，内存池在apache中任何一个阶段被使用，所以也被外部模块使用。内存池可以管理内存，Sockets 和进程等服务系统所有的资源。 内存池的使用可以降低程序设计错误的可能性。在程序中如果由于疏忽或错误造成程序未能释放已经不再使用的内存，造成内存泄露。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费，其它的程序就不能够再使用这个内存段。 客户端的程序因为运行不是非常长时间，退出后操作系统会自动释放资源，所以不是造成太大的危害。但是在服务端端程序由于长期运行，即使是一点地内存泄漏由于长期内存泄露造成服务端的崩溃。 尤其需要注意Sockets。如果建立了一个Socket，但是在业务完成时没有释放它，那么其它的程序就不能使用这块内存。这些不断建立但是未释放的Sockets会造成内存，CPU被占满。此时服务端一定会崩溃。许多服务端现在基本都是以多线程或者多进程的方式工作，这些进程或者线程如果不按设计退出只能被管理员中断。如果一个程序不停止运行，那么服务端端资源会被立马占满并且崩溃。 随着内存池的使用，开发者可以在一个已知生命周期的内存池中使用内存，sockets和进程。一旦这个内存池被摧毁，那么所有的资源都会自动的释放。这样就只有一些仔细考虑后额外的例程才会需要考虑释放内存的事情。这样就变得更简单明了，减少了开发者的负担。 重要的是，内存池可以提升服务器的性能。通常一个程序使用和释放内存，由于系统需要从虚拟内存中分配和释放内存，这些会造成许多的开销，这将显著的降低性能。并且，不管请求了多少内存，系统通常分配一个最小数量的空间。那么这将造成许多小的内存空间被浪费。经常这样做的话，那么你需要关注这些小内存的价值了. 内建池和生命周期 Apache内建的内存池都有不同的生命周期，如上图所示，该图描述了池的继承的层次结构。pglobal存在于服务器的真个运行周期，pchaild存在于整个子虚拟机主机的生命周期，pconn是每一个连接的生命周期，preq是每一个请求的生命周期。通常开发者使用最小的生命周期最小存储空间最小存放数据。 如果开发者需要一个非常大的内存空间，而且没有一个合适生命周期的内存池。一个任意内建池的子池可以被创建。程序可以像内建池一样使用这个内存池，也可以在不需要这个内存池的时候释放它。如果忘记了释放这个内存池，那么在它的父池被释放的时候它会被自动释放。释放pglobal的时候，所以的子池都将被自动释放。每一个连接池是子服务池处理连接，所有的请求池都是对应了连接池。 内存池的内部结构 如上图所示，一个池内部链接了一系列的子池，数据块，进程和回调函数。如果需要分配内存需要使用预定义的函数。这些函数不只是分配内存，并且也可以释放内存。同样的进程也可以通过内存池建立，内存释放的时候进程结束。此外，每个池可以保存关于在销毁所有存储器之前被调用的函数的信息。这样文件处理程序和套接字都可以注册一个池去销毁它。 当一个内存池被销毁的时候，apache首先回调清理函数。所有注册的文件句柄和Sockets将被关闭。之后，池讲终止所有的注册和进程。这些结束之后，数据块就被释放。通常apache并不是真的释放被其它程序使用的内存。而是将它从池中删除，将这段内存放入空闲的内存块中。这样就将分配和释放内存的消耗降至最低。内核将立即分配这些空闲的内存。只有在池中所有的内存都用完时才需要分配新的空间。 refer: Memory_resource","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"重复","slug":"repetition-work","date":"2017-02-05T14:36:33.000Z","updated":"2017-02-05T14:36:56.000Z","comments":true,"path":"2017/02/05/repetition-work/","link":"","permalink":"[object Object]/2017/02/05/repetition-work/","excerpt":"","text":"想想你去年重复了哪些工作，哪些工作占用了你的大量时间，技术支持的时候是对方没有描述清楚问题，还是自己没有理解好问题。是对方在现场操作太慢，还是自己提供的文档不够齐全。 在工作的时候哪些场景会让你不开心，不开心的原因是什么，是因为事情本身，还是这种交互之间占据了太多时间，是对方的原因，还是自己没有讲清楚的原因。 什么场景下你会感到非常的烦躁，是因为工作事情本身的原因，还是没有休息好的原因。 什么东西会影响你工作的效率，突然的电话的打扰，消息，邮箱的打扰。身边同事的打扰，什么打扰你可以忍受，什么打扰你不可以忍受。什么东西会促进你的工作效率，在工作的时候听音乐可以促进你的工作效率吗？在什么情况下你需要音乐去促进你的效率。还有什么硬件或者软件可以促进你的效率，你有争取去改进你的原有的什么方式吗？","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"人头马身","slug":"20161025","date":"2016-10-25T00:48:22.000Z","updated":"2016-11-06T07:59:18.000Z","comments":true,"path":"2016/10/25/20161025/","link":"","permalink":"[object Object]/2016/10/25/20161025/","excerpt":"","text":"(一) 来到这个城市已经十年，时间在指尖上溜过，却什么也不曾留下，一无所有的来，可是比到来变得更加得一无所有，来的时候以为能够在这个城市留下辉煌，可是我是留下来，也把我的卑微也留下。如果我手中有一把剑，我会成为一位剑客，纵横四海，无所畏惧，可是我手中没有剑。如果我会跳舞，我会在月光下，在舞台中央，在所有的目光中灼灼生辉，可是我不会跳舞。如果我活在魏晋，我会成为一个放浪形骸的人，饮觞取酒，或宠辱不惊，或尽情悲痛，可是我活在不一样的时代。如果，如果，我只是一个普普通通的一个人，什么也不会，什么也做不了。如果我手中有一个键盘，是的，我手中现在只剩下键盘。看着屏幕，顾影自怜。我是一名程序员，版本更新之后，旧的代码已经面目全非。时间也就变得面目全非。 你是否感觉到，这个世界每时每刻都在变化，在你闭上眼的那一刻，在你早上醒过来的那一刻，你已经转换到了另一个时空，细微的变化并没有让你察觉，可是在睁开眼睛的那一刻，你是否有一丝的恍惚?你不能同时存在一条河里两次，你不动，水已经动了，你跟着水动，位置已经变了。我已经变得越来越恍惚，越来越心不在焉，头脑昏沉。我的意志感觉不受束缚，手也已经开始不受控制。“你好，我叫陈晓，来自你的平行世界。”仿佛一瞬间清醒过来，感觉到恐惧，难道那个世界的科技已经发达到了这种程度。不知道为什么那个平行世界会找上我,难道是他能够感受到每个时间线，在所有的时间线上选择了我。或者我们身上有着一个相同的时间节点。记得那是一个非常普通的的晚上，我坐在我的电脑前面，可能那个时候我意外的成为了一个叠加态，在理论物理和工作两个态之间做选择。我的世界坍塌在工作上面，而另一个我坍塌在做科研，而且是理论物理的方向。“如果你能够看到，那么在明天凌晨2点到xx区xx路xx广场见面。” 刚上出租车，出租车司机就开始自说自话了，聊东聊西。他们是这个城市半夜的孤魂，永远也找不到自己的出口。接着就开始抱怨：“那些男司机每天下班回家，家里都会做好饭，喜好衣服，把一切都弄好，我们呢？休息的时候还要早起洗衣服做饭，拖地板。永远没有休息的时候。”“其实我还算幸运的了，我载完你去洗车，然后去交接车子之后就可以回家了。我的一个同事就辛苦的多了，好不容易在老家盖起了房子，贷款还没还清，老公就检查出来癌症，平常她的老公也没有对她怎么怎么好，可是却要一起去承担这种事情。看她的样子都老了好多。”她没有讲完我就到目的地了，可是感觉她永远也有讲不完的故事，然后对着不同的人讲着相似的故事。 下车之后12点多了，在这个城市中游荡，此时正是盛宴之后。商厦这时候都已经关门，却依然发出艳丽的霓虹灯。路灯这时候撑起昏黄的小伞，清冷的空气扑面而来。这时候路上已经没有什么人，可以听见脚底与路面的摩擦的声音。呼吸的声音。月亮挂在高远的天空中。此刻仿佛有着黑洞在靠近，将一切都吸引过去，包括光，内心也变得恐惧起来。 静谧一下子被打破，所有的东西都动了起来。一切都开始扭曲。所有的东西都长出了脚，高楼缓慢笨拙的移动着，路灯开始奔跑起来，远方传来响亮的嘶吼声。仿佛一只蚂蚁在人群之中一样，他们走动，巨大的脚掌在空中移动，明与暗不停的交错，我却也无处可躲，我是如此的微小，他们也感受不到我的存在。 在慌乱中我呆滞地站在原地，看着一切。 (2) 达达的马蹄，一匹马在暗黑的玻璃上，在流动的水上飞跃。它停在我的面前，载起我，飞驰而上，流动的城市形成了一个八卦阵的形状。一辆辆车子在其中左突，右冲，可是总是在这个城市中打圈。 是的，他的人生毫无价值，你看，他蜷缩在那个角落中，衣衫褴褛，比一张废纸还不如。 你看那个齿轮，他天生就是一块齿轮吗？你知道齿轮的生产过程马？他们本是一块铁，因为特殊的需要，经过高温溶成铁水，然后浇筑在模版上。 来到镜子面前，仔细的端详着这张脸，这么熟悉，我仔细的看着，仿佛看着一个非常熟悉是字一样，突然间变得非常的陌生，文字好像突然有了形象，而这张脸仿佛逐渐变成了一个符号，没有什么特点，没有美丑，没有颜色，只剩下一个粗劣的线条。另一面镜子就竖在对面，瞬间这张脸被复制了无数遍， 你是谁，你在干什么，你想要什么？","categories":[],"tags":[{"name":"人头马身","slug":"人头马身","permalink":"[object Object]/tags/人头马身/"}]},{"title":"深秋","slug":"last-Fall","date":"2016-10-22T09:28:47.000Z","updated":"2016-10-22T13:18:51.000Z","comments":true,"path":"2016/10/22/last-Fall/","link":"","permalink":"[object Object]/2016/10/22/last-Fall/","excerpt":"","text":"北方的气温已经降了下来，有必要套一件大衣了。南方开始下雨，连门都出不了，不然就要拖着一身的风雨回来了。深秋时节最美，这是生命的大繁华的时刻。不宽的水泥地，青色的矮墙，燃烧的银杏树，点燃金色的光芒，虽是下午，但是前方布满薄雾。显得非常的深远。雨巷还是随处可见，丁香一样的姑娘早已经离去，雨水依然滴答这石板。秋天是一个收获的季节。桔树，葡萄树经过一个夏天的生长，现在人们欣喜的把果子采摘下来，成为了人们口中甜美的美食。 深秋了。","categories":[],"tags":[]},{"title":"自测网关安全性","slug":"gateway-s-safe","date":"2016-10-20T09:28:16.000Z","updated":"2016-10-20T09:35:57.000Z","comments":true,"path":"2016/10/20/gateway-s-safe/","link":"","permalink":"[object Object]/2016/10/20/gateway-s-safe/","excerpt":"","text":"网关的主要作用是转换原B/S，C/S系统的协议，将原来未加密的协议转换成加密的协议。在这里网关将未加密的HTTP协议或者TCP协议转换成SSL协议。任何一个增加的系统都会增加安全性的问题，作为一款加密产品，那么它更应该注重自生的安全性问题。 IP和端口扫描(nmap，netcat) 对访问用户压测，看看有大量用户访问时是否会断开连接(burpsuit, ab, loadrunner) 查看每一个连接中的关键数据是否加密 传输的数据是否加密 对文件上传和下载是否满足用户权限的要求，是否保护 对shell和sql是否防止注入 对网关的系统和服务器进行安全性扫描","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"一个叫天南，一个叫地北","slug":"wood","date":"2016-10-17T09:24:02.000Z","updated":"2016-10-17T12:33:09.000Z","comments":true,"path":"2016/10/17/wood/","link":"","permalink":"[object Object]/2016/10/17/wood/","excerpt":"","text":"南方总是温润的。南方的一半是水组成的，水的一半给了人，另一半却给了眼睛。到那里都是水波荡漾一片。南方的早晨总是在泼绿中蒙着一层纱。犹抱琵琶半遮面的。南方的雪是温和的，滋润美艳之至了，这时候南方就是一幅留白的山水画了，南方是一棵柳树，她就那样站在那里，微风轻拂着柳条，岁月静好。南方的冬天却也是暴戾的，毫不留情的把你的脚放到冰中，喜欢着南方的好，忍受着南方的暴戾。 懂得南方却不懂北方。一个叫木头，一个叫马尾。 -———记于北方途中","categories":[],"tags":[{"name":"Caprice","slug":"Caprice","permalink":"[object Object]/tags/Caprice/"}]},{"title":"自述Tcp超时与重传","slug":"Net-Tcp","date":"2016-10-16T03:02:39.000Z","updated":"2016-10-16T07:38:20.000Z","comments":true,"path":"2016/10/16/Net-Tcp/","link":"","permalink":"[object Object]/2016/10/16/Net-Tcp/","excerpt":"","text":"将tcp的超时与重传的文档太多了，我也是从tcp/ip详解这本书上学习了。所以如果你对这个不熟悉，希望你先看书，不然基于我自己的理解，很容易让人误解。但是如果有大神，如果有什么写错，或者理解错误的东西，希望指出，不胜感激。 tcp的超时设置是为了防止网络问题和节省时间之间的一个平衡，如果不设置超时，当一个ack没有获取，那么此时直接返回网络错误。重传是为了防止偶然的网络问题。超时的时间间隔大部分都是指数间隔，而不是线性的。 tcp的所有超时的地方，从第一个客户端读取 syn ＋ ack 超时，超时与重传connect 超时响应超时读写超时timewait超时 超时重传机制哪些会超时，哪些直接发送reset断开连接或者超时多长。","categories":[],"tags":[{"name":"Tech, Net","slug":"Tech-Net","permalink":"[object Object]/tags/Tech-Net/"}]},{"title":"一个偶然的arp网络错误","slug":"Net-arp","date":"2016-10-16T03:02:27.000Z","updated":"2017-01-21T09:27:48.000Z","comments":true,"path":"2016/10/16/Net-arp/","link":"","permalink":"[object Object]/2016/10/16/Net-arp/","excerpt":"","text":"在网络的使用中这个是我们比较少关注的一个协议，它是用来查看ip地址和mac地址的对应关系。 一般情况下网络问题很少出现在这个地方。而且如果查看这个值出现问题的时候，一般是上层的协议出现了问题，或者就是整个网络出现了问题。 但是今天需要讲述一个比较特殊的情况下arp的网络问题。问题的起源是我使用openvpn搭建一个client-to-client 的环境。就是使用一台openvpn的服务器，然后使用两台openvpn的客户端去连接openvpn的服务器。我在openvpn中配好 client-to-client 选项后，然后两台openvpn的客户端可以ping通服务端，也可以看到下发的策略。但是在两台客户端的中相互ping对方，却是不通的。查看ip和tcp，都是正常的。没有检查到异常，但是一直都是不通的。 最后没有办法，只能按照网络协议层一层一层的往下去分析。在windows的cmd下，查看路由 route print。路由正常。ip和端口正常，ip层和tcp层都是正常的。使用arp -a的指令，得到 arp -a 172.16.0.2 ether 00:ff:90:4e:20:cc C tap0 172.16.0.3 ether 00:ff:90:4e:20:cc C tap0 172.16.0.0/16 是虚拟IP的地址，第三项是对应的Mac地址，所以到链路层之后，有两个相同的mac地址。所以从mac地址转换成IP地址的时候丢失了IP地址。所以一直访问不通。 为什么会有两个相同的mac地址呢？第二个openvpn的客户端是直接复制第一个openvpn的虚拟机。所以出现了两个相同的mac地址。修改其中一个虚拟IP的mac地址之后就可以相互ping通对方了。 如果想重现问题，可以将两个IP地址改成相同的mac地址，查看一下你的那边会出现什么情况。 ###虚拟IP arp -a 192.168.41.97 ether 00:0C:29:EB:70:DA C eth0 192.168.41.92 ether 00:0C:29:EB:70:DA C eth0 有时候我们可以在同一台机器上看到两个IP有相同的物理地址。traceroute 这两个IP都是正常的，可以访问的。没有出现上面不能访问的情况。 MAC destination MAC source Source Address Destination Address(ip/Virtual_ip) MAC destination MAC source 在这种情况下主机中发出的数据中包含了目标地址的IP，所以可以正常到达目标主机。但是如果是两个Mac相同，发送apr的tell数据包的时候，会有两个地方都会响应，那么就会造成Mac地址冲突了。","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"绑定Apache信息","slug":"Apache-Info","date":"2016-10-16T03:02:11.000Z","updated":"2017-07-09T03:01:31.000Z","comments":true,"path":"2016/10/16/Apache-Info/","link":"","permalink":"[object Object]/2016/10/16/Apache-Info/","excerpt":"","text":"在apache的使用中，如果是一个apache代理服务器，并且使用的证书的话，我们不可避免的需要将从前端和证书中的信息传递给后端处理。一般情况下，我们都是将这些信息绑定在http头中，cookie项中，这样后端比较容易处理。 幸运的是，apache为我们提供了这么一个可选函数，可以任何的一个模块中获取你需要的信息。这个可选函数是在模块 mod_nw_ssl 中定义。 APR_REGISTER_OPTIONAL_FN(ssl_var_lookup); 可选函数 apache 可选函数原理 可选函数实现 声明 APR_DECLARE_OPTIONAL_FN(char *, ssl_var_lookup, ​ (apr_pool_t *, server_rec *, ​ conn_rec *, request_rec *, ​ char *)); 实现 char ssl_var_lookup(apr_pool_t p, server_rec s, conn_rec c, request_rec r, char var) 注册 APR_REGISTER_OPTIONAL_FN(ssl_var_lookup); 获取 static APR_OPTIONAL_FN_TYPE(ssl_var_lookup) *pfn_ssl_lookup = NULL;pfn_ssl_lookup = APR_RETRIEVE_OPTIONAL_FN(ssl_var_lookup); 调用 if (pfn_ssl_lookup) { server_rec *s = r-&gt;server ? r-&gt;server : c-&gt;base_server; value = pfn_ssl_lookup(pool, s, c, r, var); } 信息绑定原理 可查询信息 http 头中的信息 ssl 的参数，和对应使用的用户证书的各项内容。 连接 socket 的各项参数- 格式化的各种时间 保存在 r-&gt;notes 中的的环境变量- 如何找不到 key 对应的 value，则返回空字符串。 如何防止假冒参数 ? 如果用户服务器里面有一个与网关相同的参数，你会怎么处理？ 用下划线替换假冒URL参数名的第一个字符","categories":[],"tags":[{"name":"Tech, Apache","slug":"Tech-Apache","permalink":"[object Object]/tags/Tech-Apache/"}]},{"title":"困","slug":"Trap","date":"2016-10-16T03:02:00.000Z","updated":"2016-10-16T04:25:01.000Z","comments":true,"path":"2016/10/16/Trap/","link":"","permalink":"[object Object]/2016/10/16/Trap/","excerpt":"","text":"为身所累，为圈所困。 记得有一次和朋友去寺庙玩，因为是在旅游，所以一路都是背着旅行包的。由于那时候宁可信其有，不可信其无。所以到了寺庙都会虔诚的拜拜，不是为了什么。我就一间房一间房的去看，去拜拜。当我来到一座大佛面前时，直接就拜了下去，这时候在这间房子的老师傅说：”施主，拜佛的时候放下你的背包.”犹如当头一棒，在路上已经忘了身上的负担，感觉背包已经和自己融为一体， 昨天去寒山寺，身上不着一物，忽然发现最重的负担是放不下，背包可以放下，可是放不下就如着空气，无影无形中，一个圈，一句话，却轻易的困住了自己。在你最脆弱的时候犹如大山直接压着。我看着金光闪闪的尊者和罗汉，可是我却找不大一个答案。听着钟声，却是对愁。","categories":[],"tags":[{"name":"Caprice","slug":"Caprice","permalink":"[object Object]/tags/Caprice/"}]},{"title":"Apache 超时设置","slug":"Timeout","date":"2016-10-16T03:01:53.000Z","updated":"2016-10-17T09:05:43.000Z","comments":true,"path":"2016/10/16/Timeout/","link":"","permalink":"[object Object]/2016/10/16/Timeout/","excerpt":"","text":"在apache的使用过程中，我们可以看到许多的超时设置，因为apache是一个web服务器，所以它的超时是包含底层的超时设置，例如tcp协议的。所以这一篇文档包含http，ssl，tcp等协议的超时设置。 timeout tcp读写超时(wait_for_io_or_timeout) t &gt; 0 – read and write calls return APR_TIMEUP if specified time elapsess with no data read or written t == 0 – read and write calls never block t &lt; 0 – read and write calls block keepalivetimeout 在keepalivetimeout时间后没有子请求，断开连接(ap_process_http_connection) proxytimeout 没有设置的时候与 timeout 的一样 RequestReadTimeout（reqtimeout_init） 设置读取http头和http正文最大和最小超时时间 默认值： MRT_DEFAULT_HEADER_TIMEOUT 20 MRT_DEFAULT_HEADER_MAX_TIMEOUT 40 MRT_DEFAULT_HEADER_MIN_RATE 500 MRT_DEFAULT_BODY_TIMEOUT 20 MRT_DEFAULT_BODY_MAX_TIMEOUT 0 MRT_DEFAULT_BODY_MIN_RATE 500 SSLSessionCacheTimeout ssl session 超时时间","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"井","slug":"shaft","date":"2016-10-16T03:01:46.000Z","updated":"2016-12-19T11:16:22.000Z","comments":true,"path":"2016/10/16/shaft/","link":"","permalink":"[object Object]/2016/10/16/shaft/","excerpt":"","text":"村里有一口井每至夜深人静之时总能听见它涌动的声音折磨无法入睡 我在村子里面徘徊村头两座小山村尾两棵大白杨那一口井就藏在村中间 我像一头野牛一样在这里面冲撞我 留着汗奔跑，我将坝台高驻我爬上山，我爬上树不，我不能停歇 我找到这口井了毁灭它，将石头掩埋将热闹覆盖 夜深人静，我听见泉水涌动的声音将石头取出将热闹去除只身跳入这口井中","categories":[],"tags":[{"name":"Caprice","slug":"Caprice","permalink":"[object Object]/tags/Caprice/"}]},{"title":"窗外","slug":"Out-of-Windows","date":"2016-10-16T03:01:35.000Z","updated":"2016-10-16T04:28:19.000Z","comments":true,"path":"2016/10/16/Out-of-Windows/","link":"","permalink":"[object Object]/2016/10/16/Out-of-Windows/","excerpt":"","text":"被困在车厢里。车厢因为站票挤满了人，举步维艰，即使能移动，也只是在车厢里，最后还是回到自己的位置。人身上发出的气味，泡面的腐味因不开窗而始终弥漫。有种窒息的感觉。人们聊天的声音，手机叮叮响的声音爆炸在耳边。即使在深夜里，那永不停歇的火车运动的机械声。在深夜的梦里回响。一个人趴在窗上，无事可做，仅仅趴在窗上，在那积满灰尘的窗上。一心望着外面。望着窗外。转过一座山，并行的湖。天地的蓝天白云相接。旋转而起的树木，碧波荡漾的竹林，其间点缀无数点点星星。九万里的大鸟在云层之外翱翔。火车在盘着山，就如此彳亍着，有时可以看见火车外有人在奔跑，引起车里人的嘲哄声，但马上连他的背影也看不见了。就这样一直望着窗外一天一夜，期间不断的食品叫卖声与引起的喧闹嘲杂声不闻不问。突然有种莫名的冲动，毅然决然的跳下火车，投向那森林的最深处，走向海的绝渊中，飞向那无人触及的圣地。雨打在窗外，凝聚，演绎着千姿百态，最后回于水中，雨仅仅只是水，但他或许会变成气，变成雾，雪，血。突然有一刻，仅仅那一刻，从窗外投射来的一缕阳光，透过窗，透过身体，照在心上。","categories":[],"tags":[{"name":"Caprice","slug":"Caprice","permalink":"[object Object]/tags/Caprice/"}]},{"title":"PHP Session超时设置","slug":"PHP-Session","date":"2016-10-16T03:01:02.000Z","updated":"2016-10-16T07:30:54.000Z","comments":true,"path":"2016/10/16/PHP-Session/","link":"","permalink":"[object Object]/2016/10/16/PHP-Session/","excerpt":"","text":"PHP控制session的方法环境：PHP的session控制使用crond定时检查debian3， ubuntu14.0.4 PHP的session文件保存在 /var/lib/php5 中，如果是使用cookie保存session的方法，可以在浏览器中查看cookie，查看两个值是不是一样的。如果你手动清除这个文件，登陆页面马上放回到你需要跳转的页面。所以对session时间的控制就是对删除session文件时间的控制。 删除session文件是使用首先查看 /etc/cron.d/php5 的文件 09,39 root [ -d /var/lib/php5 ] &amp;&amp; find /var/lib/php5/ -type f -cmin +$(/usr/lib/php5/maxlifetime) -print0 | xargs -r -0 rm 从这里可以看出系统定时检查session文件的修改时间，一旦超出maxlifetime，就将它删除。所以最后的控制就在 /usr/lib/php5/maxlifetime 中。 我们查看这个文件做了什么事情这个文件中默认最大超时时间为 1440 秒，然后与 /etc/php5/*/php.ini 的session.gc_maxlifetime 时间比较，哪个大取哪个值。在 /etc/php5/*/php.ini 中默认时间也是 1440 秒，所以非常的麻烦修改三个文件。 最简单的设置session超时时间直接修改 /usr/lib/php5/maxlifetime echo $time 这个 $time 就是你设置的超时分钟。","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"空城","slug":"City","date":"2016-10-16T03:00:50.000Z","updated":"2016-10-16T04:30:54.000Z","comments":true,"path":"2016/10/16/City/","link":"","permalink":"[object Object]/2016/10/16/City/","excerpt":"","text":"早上醒来，我突然发现自己得了空人症，这个城市还是原来的城市，这个城市的运作还是按照原来的方式，可是在我的眼里看不到一个人，和这个人周边的东西。仿佛这个世界上的人都消失了，只剩下机器在运作。 你可以感受到，在街上还是有那么多的车在开，可是你看不到一个人，地铁仍在开，你可以悠闲的坐在任何一个位置，因为没有人跟你抢，尤其是在中国这个大城市中，感觉尤为强烈。 你就这样一个人走在这个空空荡荡的大街上，眼中空无一人。","categories":[],"tags":[{"name":"Caprice","slug":"Caprice","permalink":"[object Object]/tags/Caprice/"}]},{"title":"夏天","slug":"Summer","date":"2016-10-16T03:00:43.000Z","updated":"2016-10-16T04:31:20.000Z","comments":true,"path":"2016/10/16/Summer/","link":"","permalink":"[object Object]/2016/10/16/Summer/","excerpt":"","text":"有时候会突然的想起你，我尽力去回想你的脸，你的笑容，我们在一起的每一个细节。手机里面还有你的号码，你的照片。可是这些都仿佛是一个遥远的梦，现在想来如此的不真实。我一直埋得很深，我总是很忙的样子。不愿意停下来，因为一旦停下来，仿佛一下子掉入一个无底的深渊。","categories":[],"tags":[{"name":"Caprice","slug":"Caprice","permalink":"[object Object]/tags/Caprice/"}]},{"title":"剑","slug":"Sword","date":"2016-10-16T03:00:36.000Z","updated":"2016-10-16T04:31:48.000Z","comments":true,"path":"2016/10/16/Sword/","link":"","permalink":"[object Object]/2016/10/16/Sword/","excerpt":"","text":"如果我手中有一把剑，我会成为一位剑客，纵横四海，无所畏惧，可是我手中没有剑。如果我会跳舞，我会在月光下，在舞台中央，在所有的目光中灼灼生辉，可是我不会跳舞。如果我活在魏晋，我会成为一个放浪形骸的人，饮觞取酒，或宠辱不惊，或尽情悲痛，可是我活在不一样的时代。 如果，如果，我只是一个普普通通的一个人，什么也不会，什么也做不了。 给我一把剑，我却只会伤了别人，也伤了自己。即使我会跳舞，却也会踩到你的脚，走错了步。即使我回到那个时代，我依然会退缩，退缩到一个安全的地带。我回不到过去，也没有如果。","categories":[],"tags":[{"name":"Caprice","slug":"Caprice","permalink":"[object Object]/tags/Caprice/"}]},{"title":"Library20160717","slug":"Library","date":"2016-10-16T03:00:28.000Z","updated":"2017-05-28T11:05:55.000Z","comments":true,"path":"2016/10/16/Library/","link":"","permalink":"[object Object]/2016/10/16/Library/","excerpt":"","text":"我看到你表现得很强势，你总是不让人质疑你。你的表情冷漠，你自负。你说你是一个天才。只是一个没人发现的天才。可是，我却看到你的逃避，孤独，自卑，你一直在逃避自己，你害怕真实的你，你身处于海上，在一条小船上，你并不是一座孤岛，你只是漂流的一条小船而已。风来，你就吹风，随风而走，雨来，你就在海上写字。你就这样直接地暴露在这个海上，唯一的陪伴就是你的海面的倒影，可是这个只是使你更加的顾影自怜而已。 忽然什么都不想做，就这样毫无目的的敲打着键盘，它会带我到哪里呢？现在像是陷入了一个低谷中一样，看不到希望，明知道自己是一只井底之蛙，却也无法爬出这个绝壁。这只青蛙也许是悲哀的，其他的青蛙都能够很安然的活在这个世界中，从不关心这个天，这个天外有什么？可它偏偏看到一只天鹅飞过，这片天就变得不太一样了。它明知道这片天不只是这么小，因为它看过有天鹅飞过，它看见过的是别的从不在乎的。它们从来就不关心这些。 不知道是杜撰的还是一个真实的故事，一位智者让他的学生经过一个花园，不回头的情况下获取一样你最喜欢的东西。学生面对一开始的大麦穗的时候总是在想后面总会有更大的。或者在犹豫的那一个刹那，身体已经跨过去了。就像另一个智者告诉的，下一个总是最好的。然后在自我安慰中在不经意间又跨过几步。我只走了几步，我以为我的最重要的东西是比任何人都要快的到达终点，所以我不愿意去等待，我总是急不可耐的就出发了。然而我觉得我已经变得十分的老迈了。我曾经为为没有尝过苹果而失望，现在尝过苹果变得更加的失望，因为我失去了我最喜欢的那个苹果。 讲故事总是非常的容易和轻巧，可是朝菌不知晦朔,蟪蛄不知春秋，即使我们知道故事的结局是怎样的，可是依然无法改变。","categories":[],"tags":[{"name":"Caprice","slug":"Caprice","permalink":"[object Object]/tags/Caprice/"}]},{"title":"早开的紫藤","slug":"flower","date":"2016-10-16T03:00:15.000Z","updated":"2016-12-10T06:32:06.000Z","comments":true,"path":"2016/10/16/flower/","link":"","permalink":"[object Object]/2016/10/16/flower/","excerpt":"","text":"四月初，我看见路边的紫藤萝已经开了。这种花开像瀑布一样，倾泻而下，一朵一朵鲜活的像一个个笑容一样， 可是我们去得太早，花开几多，零零散散。","categories":[],"tags":[{"name":"Caprice","slug":"Caprice","permalink":"[object Object]/tags/Caprice/"}]},{"title":"SSL Session 和 Session Tickets","slug":"SSL-Session","date":"2016-10-16T03:00:00.000Z","updated":"2017-03-22T12:01:40.000Z","comments":true,"path":"2016/10/16/SSL-Session/","link":"","permalink":"[object Object]/2016/10/16/SSL-Session/","excerpt":"","text":"背景在对http和https性能比较的时候，可以发现http性能比https高出几个数量级。因为https使用了tls/SSL协议，客户端与服务端进行ssl握手，在握手的时候需要进行密钥协商，密钥交换，身份认证等过程，尤其是在这中间必须要传递证书确定身份。 为了在安全和性能之间寻找一个平衡点，SSL Session 是解决这个问题的一个方法。SSL Session的安全性是建立在必需要获取整个 Session ，只是获取明文传输的的Session ID 是无法握手成功的，Session是缓存在客户端中，要窃取客户端的Session是非常困难的。 SSLSessionTickets在apache中是默认开启的。如果需要关闭必须加上 SSLSessionTickets Off。 Client Server ClientHello (SessionTicket extension) --------&gt; ServerHello (empty SessionTicket extension) NewSessionTicket [ChangeCipherSpec] &lt;-------- Finished [ChangeCipherSpec] Finished --------&gt; Application Data &lt;-------&gt; Application Data 测试session ticket重用 openssl s_client -connect host:port -sess_out session_file openssl s_client -connect host:port -sess_in session_file 第一次访问的New session New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384 Server public key is 2048 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES256-GCM-SHA384 Session-ID: 596B3F7202A4E299F7EACF4C73818ED048085DFEA6DF31780C225C5D3045DD9A Session-ID-ctx: Master-Key: E96BA7797E9415D0C052F5212BEC6F9D009877C277535CB7B121B091BF24AA1FA06FD2FABE9E59EDBA6499412CD404B1 Key-Arg : None PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 300 (seconds) TLS session ticket: 0000 - a0 b1 ee 17 03 57 df 58-f0 fc 7e 34 8e f7 c1 13 .....W.X..~4.... 0010 - 7a af d5 05 49 ea 1c 34-07 01 6e 08 f2 92 90 3f z...I..4..n....? 0020 - e0 82 f9 c3 5f 27 88 98-fc 2e d3 36 bf d0 71 c3 ...._&#39;.....6..q. 0030 - c2 41 93 dd ac ba 80 15-9c 6f c2 07 ac 28 0f a7 .A.......o...(.. 0040 - 3a 1a 0e 58 74 09 36 0b-ce fe 52 95 6b b6 f1 f7 :..Xt.6...R.k... 0050 - dd 75 b8 04 8e ae 08 65-c5 e0 bb 49 0c f6 8a 9f .u.....e...I.... 0060 - 51 f1 36 44 35 a3 1d 07-dd 3a 48 63 4a e7 74 a4 Q.6D5....:HcJ.t. 0070 - c5 3e 0a 1e 5a fd 10 66-18 0f ae e2 c0 87 77 3c .&gt;..Z..f......w&lt; 0080 - 32 73 68 12 4e 89 76 aa-0f c3 99 90 96 36 2a 40 2sh.N.v......6*@ 0090 - d2 60 a6 6d 8d da a6 46-13 16 89 56 a0 28 f1 2c .`.m...F...V.(., 00a0 - 9c 7d 21 df 05 b6 1e 7c-99 cb 7b 5a a8 97 f3 72 .}!....|..{Z...r 00b0 - ba 1d 6d 7e a3 99 bc 4b-a8 81 a6 7a b9 e3 9e d4 ..m~...K...z.... Start Time: 1490175208 Timeout : 300 (sec) Verify return code: 19 (self signed certificate in certificate chain) 使用session访问 Reused, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384 Server public key is 2048 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES256-GCM-SHA384 Session-ID: 596B3F7202A4E299F7EACF4C73818ED048085DFEA6DF31780C225C5D3045DD9A Session-ID-ctx: Master-Key: E96BA7797E9415D0C052F5212BEC6F9D009877C277535CB7B121B091BF24AA1FA06FD2FABE9E59EDBA6499412CD404B1 Key-Arg : None PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 300 (seconds) TLS session ticket: 0000 - a0 b1 ee 17 03 57 df 58-f0 fc 7e 34 8e f7 c1 13 .....W.X..~4.... 0010 - 7a af d5 05 49 ea 1c 34-07 01 6e 08 f2 92 90 3f z...I..4..n....? 0020 - e0 82 f9 c3 5f 27 88 98-fc 2e d3 36 bf d0 71 c3 ...._&#39;.....6..q. 0030 - c2 41 93 dd ac ba 80 15-9c 6f c2 07 ac 28 0f a7 .A.......o...(.. 0040 - 3a 1a 0e 58 74 09 36 0b-ce fe 52 95 6b b6 f1 f7 :..Xt.6...R.k... 0050 - dd 75 b8 04 8e ae 08 65-c5 e0 bb 49 0c f6 8a 9f .u.....e...I.... 0060 - 51 f1 36 44 35 a3 1d 07-dd 3a 48 63 4a e7 74 a4 Q.6D5....:HcJ.t. 0070 - c5 3e 0a 1e 5a fd 10 66-18 0f ae e2 c0 87 77 3c .&gt;..Z..f......w&lt; 0080 - 32 73 68 12 4e 89 76 aa-0f c3 99 90 96 36 2a 40 2sh.N.v......6*@ 0090 - d2 60 a6 6d 8d da a6 46-13 16 89 56 a0 28 f1 2c .`.m...F...V.(., 00a0 - 9c 7d 21 df 05 b6 1e 7c-99 cb 7b 5a a8 97 f3 72 .}!....|..{Z...r 00b0 - ba 1d 6d 7e a3 99 bc 4b-a8 81 a6 7a b9 e3 9e d4 ..m~...K...z.... Start Time: 1490175208 Timeout : 300 (sec) Verify return code: 19 (self signed certificate in certificate chain) session-id 重用测试 openssl s_client -connect host:port -reconnect New, TLSv1/SSLv3, Cipher is AES256-SHA Server public key is 2048 bit SSL-Session: Protocol : TLSv1 Cipher : AES256-SHA Session-ID: 405763BDF7B0AFC42E44F865DFCB277167E347CCC393B374544671FC161570D5 Session-ID-ctx: Master-Key: 566E880A4F167098ECFE1EC4230B4BF7A932211DBDE24033976C90BCA7D04813457E7D395D2FEF19B12175181C070C55 Key-Arg : None Start Time: 1490175819 Timeout : 300 (sec) Verify return code: 19 (self signed certificate in certificate chain --- drop connection and then reconnect CONNECTED(00000003) --- Reused, TLSv1/SSLv3, Cipher is AES256-SHA SSL-Session: Protocol : TLSv1 Cipher : AES256-SHA Session-ID: 405763BDF7B0AFC42E44F865DFCB277167E347CCC393B374544671FC161570D5 Session-ID-ctx: Master-Key: 566E880A4F167098ECFE1EC4230B4BF7A932211DBDE24033976C90BCA7D04813457E7D395D2FEF19B12175181C070C55 Key-Arg : None Start Time: 1490175819 Timeout : 300 (sec) Verify return code: 19 (self signed certificate in certificate chain) --- refer:openssl cookbook","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"Apache缓存过滤及其原理","slug":"Apache-Cache","date":"2016-10-16T02:59:47.000Z","updated":"2017-03-21T23:22:36.000Z","comments":true,"path":"2016/10/16/Apache-Cache/","link":"","permalink":"[object Object]/2016/10/16/Apache-Cache/","excerpt":"","text":"背景apche 提供了cache的功能，能够将应用服务端的资源缓存在apache中，尤其是在apache是代理服务器，原始服务器的物理距离非常远的时候，性能就能够非常好的体现。 所以此时的网关服务器也可以作为缓存服务器使用。因为公司使用的是apache2.0系列的。所以在它那里发现它只支持URL的strcasecmp匹配。所以匹配所有的URL为 ‘/‘。但是我们希望提供普遍的过滤功能。只缓存 .jpg,.png,.css 等不变的内容。而将经常需要改成的 .html , .js 不缓存。 所以我们的方案是在 cacheenable 中增加一个可变参数，正则配置的参数。当正则匹配存在的时候，只使用正则批准，如果不存在，则使用原来的url的匹配。保证与原2.0的兼容性。 网关cache原理 不存在缓存的时候，客户端发送请求给网关，网关再向后端发送请求，然后返回给网关，网关返回给客户端。 存在缓存的时候，首先，mod_cache将是一个URL映射模块，也就是说，如果一个URL已经被缓存并且这个缓存尚未失效，该请求将由mod_cache直接处理。这也意味着在处理一个请求时通常还要发生的其他阶段：比如权限验证，mod_proxy或mod_rewrite处理的阶段，将不会发生。网关可以直接返回内容给客户端。 cache 类型mem基于mem缓存,在高级设置中已经实现，填入mem会产生配置如下 CacheEnable mem MCacheSize 4096 MCacheMaxObjectCount 4 MCacheMinObjectSize 1 MCacheMaxObjectSize 1048576 disk基于disk缓存，需要另外填写配置文件 CacheDefaultExpire 3600 CacheEnable disk / CacheRoot /tmp/apacheCache CacheDirLevels 3 CacheDirLength 4 CacheMaxFileSize 1048576 CacheMinFileSize 10 ramdisk实现方案基于disk缓存，将CacheRoot设置为内存盘目录，开机的时候自动建立整个内存的10%用于存放缓存。​ 缓存文件在CacheRoot的目录下，生成带后缀的缓存文件.data 和 .header。可以使用strings命令查看文件.data保存了缓存文件内容.header保存了缓存文件的头信息。 自动测试 使用curl发送请求 从请求中解析url，从url中获取服务路径号和url的路径 从服务路径中获取对应服务的缓存header文件，使用 strings 解析，使用grep搜索url的路径来判断url是否在缓存中。 性能测试大文件性能测试 ab -n 100 -c 100 https://192.168.41.92:451/icons/123.png Server Hostname: 192.168.41.92 SSL/TLS Protocol: TLSv1/SSLv3,AES128-SHA,1024,128 Document Path: /icons/123.png Document Length: 8675067 bytes (8.27M) Concurrency Level: 100 Complete requests: 100 Failed requests: 0 Write errors: 0 Total transferred: 867547978 bytes HTML transferred: 867506700 bytes Server Software: Apache/2.4.7 Time taken for tests: 16.630 seconds Requests per second: 6.01 [#/sec] (mean) Time per request: 16630.198 [ms] (mean) Time per request: 166.302 [ms] (mean, across all concurrent requests) Transfer rate: 50943.94 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 29 3853 1878.0 4418 6428 Processing: 1629 7901 3349.7 9461 11308 Waiting: 13 992 1020.1 505 3371 Total: 1658 11754 5163.3 13795 16620 Server Software: SSL/5.x.x Time taken for tests: 11.467 seconds Requests per second: 8.72 [#/sec] (mean) Time per request: 11467.149 [ms] (mean) Time per request: 114.671 [ms] (mean, across all concurrent requests) Transfer rate: 73881.91 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 4 4435 3071.4 5345 8180 Processing: 293 1948 1288.8 1616 4072 Waiting: 0 18 18.2 11 87 Total: 300 6383 4301.5 6982 11466 小文件性能测试 ab -n 1500 -c 1500 https://192.168.41.92:452/ Server Hostname: 192.168.41.92 Server Port: 452 SSL/TLS Protocol: TLSv1/SSLv3,AES128-SHA,1024,128 Document Path: / Document Length: 12166 bytes Concurrency Level: 1500 Complete requests: 1500 Failed requests: 0 Write errors: 0 Total transferred: 18788981 bytes HTML transferred: 18249000 bytes Server Software: Apache/2.4.7 Time taken for tests: 3.901 seconds Requests per second: 384.50 [#/sec] (mean) Time per request: 3901.171 [ms] (mean) Time per request: 2.601 [ms] (mean, across all concurrent requests) Transfer rate: 4703.36 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 84 367 412.0 314 3504 Processing: 5 23 10.9 21 111 Waiting: 4 21 10.4 18 101 Total: 103 391 414.1 336 3544 Server Software: SSL/5.x.x Time taken for tests: 3.234 seconds Requests per second: 463.88 [#/sec] (mean) Time per request: 3233.575 [ms] (mean) Time per request: 2.156 [ms] (mean, across all concurrent requests) Transfer rate: 5707.93 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 83 261 31.1 267 340 Processing: 1 14 7.3 13 55 Waiting: 0 12 7.0 11 53 Total: 90 275 31.5 281 344 测试分析 使用cache的时候性能比没有使用时提高20%-30%性能。 文件越多，性能越高。 因为ab测试时是单文件测试，但是真实情况下多请求的时候性能是叠加的。 缓存满时的行为缓存文件大于内存盘的空间时的报错： error.log:10172:[Wed Jul 20 11:20:29 2016] [error] cache_disk: Error when writing cache file for URL 192.168.41.92/icons/123.png? 手动过期直接删除CacheRoot目录下生成的缓存文件 清理磁盘缓冲区htcacheclean 可以用于将mod_disk_cache的磁盘缓冲区占用的空间保持在一个合理的水平。在SSL5.2.4中没用编译这个工具，需要增加 2.4的mod_cache配置过滤 url 指令 CacheQuickHandler off &lt;LocationMatch &quot;.*(jpg|gif)&quot;&gt; CacheEnable disk &lt;/LocationMatch&gt; CacheRoot /tmp/apacheCache CacheDirLevels 3 CacheDirLength 4 CacheMaxFileSize 1048576 CacheMinFileSize 10 在LocationMatch 的容器中加入 CacheEnable 的指令，将2.0作用域是RSRC_CONF变为RSRC_CONF|OR_AUTHCFG。 CacheQuickHandler off 将快速处理的挂钩关闭， 将处理阶段延后到handler业务处理阶段 这个指令将原来的 ap_run_quick_handler 转到 ap_run_handler 阶段, 因为 ap_location_walk 阶段在 ap_run_quick_handler 阶段之后，对url的处理也是在ap_run_quick_handler 之后的。 过滤器的处理apache 2.0 mod_cache 实现url过滤功能原mod_cache配置 CacheEnable disk / 其中 ／ 表示 url-string，在代码中这个url-string只在ap_cache_get_providers的函数中对providers进行了判断， if ((ent[i].url) &amp;&amp; !strncasecmp(url, ent[i].url, ent[i].urllen)) 其中 url 表示 r-&gt;parsed_uri.path， ent[i].url 表示 url-string。通过这个判断来选择providers。 实现url过滤 所有如果需要在 apache 2.0 mod_cache 实现url过滤功能，只需要改造这个条件语句，将这个条件变成正则表达式的判断。在 apache2.0 提供了 c 接口啊正则表达式接口。也可以使用 httpd.h 中的ap_pregcomp等接口实现。配置变成 CacheEnable disk .*(jpg|gif) CacheDefaultExpire 3600 CacheRoot /kssl/HRP/cfg/5/cache/ramdisk CacheDirLevels 3 CacheDirLength 4 CacheMaxFileSize 10485760000 CacheMinFileSize 10 不需要使用Location的容器“.*(jpg|gif)”正则匹配 gif和jpg的图片。 浏览器对cache的返回码缓存文件不超时的时候，无论是刷新还是强制刷新页面，缓存文件不被修改。（直接使用缓存文件，没有走到后面的更新缓存的钩子）缓存文件超时之后，刷新IE浏览器的页面，页面返回 304 的返回码，缓存文件不更新强制刷新之后，页面返回 200 的返回码，缓存文件更新。 CacheDefaultExpire 指令指定缓存文档的默认时间（以秒为单位），如果文档中没有提供过期日期和上次修改日期。由CacheMaxExpire指令指定的值不会覆盖此设置。 CacheMaxExpire 指令指定在不检查源服务器的情况下保留可缓存HTTP文档的最大秒数。因此，文档将最多过期这个秒数。即使文档提供了到期日，也会强制执行此最大值。 参考缓冲指南","categories":[],"tags":[{"name":"Tech, Apache","slug":"Tech-Apache","permalink":"[object Object]/tags/Tech-Apache/"}]},{"title":"薛定谔的猫","slug":"Schrodinger-s-cat","date":"2016-10-16T02:22:29.000Z","updated":"2016-10-16T04:32:56.000Z","comments":true,"path":"2016/10/16/Schrodinger-s-cat/","link":"","permalink":"[object Object]/2016/10/16/Schrodinger-s-cat/","excerpt":"","text":"量子力学中，有一只神奇的猫，是薛定谔的猫。在一个盒子里有一只猫，以及少量放射性物质。在一小时内，大约有50%的概率放射性物质将会衰变并释放出毒气杀死这只猫，剩50%的概率是放射性物质不会衰变而猫将活下来。我们这个世界时间是一维的，所以我们只能看到一维的结果，可是它存在两种可能，而且两种可能发生的概率是一样的。一维的时间我们只能看到一种可能，但不能因为我们看不到另外一种可能而否定它的存在，它就存在在那里。只是你无法感受。世界是无数个平行世界叠加统计的结果，如果将这个世界分散出去，在同一个结果中蕴含了无数中可能。平行世界的我现在一定还在419办公室，手里看着最新下载的论文，琢磨着作者想要表达什么，他在什么地方创新了，我从他这里又学到了什么，得到什么新的想法。平行世界的我一定还在计算我们到底有多少个平行世界？我该怎么用 ergodic hypothesis 证明平行世界，怎样将系综理论与平行世界联系起来考虑呢？平行世界的我一定看不到现在我，他怎么会去想呢？他也一定想不到。他只关心如何用热力学与统计物理的角度去证明平行世界，又怎么会在乎其他事情呢？超越时间的存在。我将所有的我重叠在同一时刻，他们是一条确定的轨迹。他们是如此的熟悉。可是如果将平行世界加入，这个世界就变得如此的庞杂。那一个平行世界的我是如此的陌生，我们之间也是如此的陌生。 在某一刻，我仿佛回到了过去，无数个我坐在我的旁边，我看着他们，他们都很冷淡的看着我。他们不明白我心里的热切。我又走到平行世界的我那里，那里的我是如此的截然不同。他们拥有不同的人生，截然不同的轨迹。 在那一刻，觉得世界美好有趣极了，我可以跟平行世界的我谈话，跟不同成长时段的我谈话，听我讲故事，听他们讲我遗忘的事情，讲我从未经历但确实经历过的事情。","categories":[],"tags":[{"name":"Caprice","slug":"Caprice","permalink":"[object Object]/tags/Caprice/"}]},{"title":"工具","slug":"Tools","date":"2016-10-16T02:18:19.000Z","updated":"2017-02-21T06:14:01.000Z","comments":true,"path":"2016/10/16/Tools/","link":"","permalink":"[object Object]/2016/10/16/Tools/","excerpt":"","text":"都说好的工具是成功的一半，并且好的工具对提升效率有非常大的帮助，所以在这里推荐一啊下好玩的工具。 windows软件 zeal(Mac dash) API 查看工具 typrora makrdown所见即所得工具 launch 快速启动工具 everything 快速文档搜索工具 bash on-my-zsh 在线工具 processon workflowy google analyze baidu analyze google drive blog hexo 翻墙 XX-Net","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"[object Object]/tags/Tech/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-10-16T01:54:47.000Z","updated":"2016-10-16T01:58:02.000Z","comments":true,"path":"2016/10/16/hello-world/","link":"","permalink":"[object Object]/2016/10/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}