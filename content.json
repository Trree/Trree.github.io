[{"title":"消失的五月","date":"2017-05-28T11:04:21.000Z","path":"2017/05/28/disMay/","text":"","tags":[{"name":"一个程序员的日常","slug":"一个程序员的日常","permalink":"https://trree.github.io/tags/一个程序员的日常/"}]},{"title":"Apache 压力测试后的127连接","date":"2017-05-20T05:32:10.000Z","path":"2017/05/20/20170520/","text":"在对Apache（prefork多进程模式）进行压力测试对时候，发现一旦停止压力测试对时候。会出现非常多的 127.0.0.1:447 连接 背景在对Apache（prefork多进程模式）进行压力测试对时候，客户端IP：192.168.41.96网关IP和端口; 0.0.0.0:447发现一旦停止压力测试对时候。使用 netstat -an | grep 127会出现非常多的 127.0.0.1:447 连接 12tcp 0 0 127.0.0.1:38984 127.0.0.1:447 TIME_WAITtcp 0 0 127.0.0.1:38994 127.0.0.1:447 TIME_WAIT 查看的时候连接都已经是 TIME_WAIT 的状态，无法查看它是通过哪些进程查看它建立连接。我们怀疑这些连接可能对性能会有影响。所以对这个问题进行了排查。 问题解决因为所有的127.0.0.1的端口都与447端口断开连接，又因为这些无法有效都用gdb调试。所以使用 strace 的方式跟踪进程。 strace -p 683 -o filename_childpidstrace -p 899 -o filename_masterpid filename_childpid 是在压力测试的时候临时创建出来的子进程filename_masterpid 是Apache的主进程 在压力测试时候出现的子进程中可以看到 12accept(3, &#123;sa_family=AF_INET, sin_port=htons(36448), sin_addr=inet_addr(&quot;127.0.0.1&quot;)&#125;, [16]) = 6getsockname(6, &#123;sa_family=AF_INET, sin_port=htons(447), sin_addr=inet_addr(&quot;127.0.0.1&quot;)&#125;, [16]) = 0 发现这个子进程是accept了连接。但是这些环回地址是如何产生的？ 查看主进程的 strace 文件 1234567891011waitpid(-1, 0xbffffa18, WNOHANG|WUNTRACED) = 0select(0, NULL, NULL, NULL, &#123;1, 0&#125;) = 0 (Timeout)write(5, &quot;!&quot;, 1) = 1socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 9fcntl64(9, F_GETFL) = 0x2 (flags O_RDWR)fcntl64(9, F_SETFL, O_RDWR|O_NONBLOCK) = 0connect(9, &#123;sa_family=AF_INET, sin_port=htons(447), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, 16) = -1 EINPROGRESS (Operation now in progress)poll([&#123;fd=9, events=POLLOUT, revents=POLLOUT&#125;], 1, 3000) = 1getsockopt(9, SOL_SOCKET, SO_ERROR, [0], [4]) = 0close(9) = 0--- SIGCHLD (Child exited) @ 0 (0) --- 从这里发现Apache的主进程发了connect连接，然后自己断开连接。但是为什么回出现这种情况呢？需要进一步查看代码查找原因。 原因压力测试的时候起了非常多的子进程。但是压力测试之后不需要那么多的进程。此时临时建立的子进程都阻塞在select上面。Apache采用都策略就是主进程与阻塞都子进程建立连接，然后关闭连接，所以看到都现象如上。","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"搬家","date":"2017-05-06T09:21:59.000Z","path":"2017/05/06/20170506/","text":"最近搬了新的住处，在那个地方也住了两年，现在回想一下，为什么自己会忍受那样的住了2年，我为什么要这么说呢？因为那时候刚来上海，所以对生活对要求也不是很高，是跟朋友合租的，地理位置挺方便的，而且价格也挺合理，造成的结果就是房子比较老，所以一切配套的都是老家具。因为对这个地方最初对定位就是睡觉。所以满足生活的基本要求就满足了。就这样度过了两年。 现在搬到公司附近，有了属于自己的独立的空间。而且家具都是比较新的。这一切突然激发了自己的装饰欲望。 于是在地板上铺好地毯。买了自己一直想种的花。 买了梵高的星空，买了花瓶。买了衣架，买了真空袋把一切都收拾的整整齐齐。就连常年治不好的叠被子也因为不和谐而变得自然。 一直知道自己需要什么，可是在老的住处，看着那些陈旧的老东西，所有都还是老样子，没有改变。 这一切都从我拥有了一双象牙筷子说起。","tags":[{"name":"Think","slug":"Think","permalink":"https://trree.github.io/tags/Think/"}]},{"title":"系统内存不足","date":"2017-04-27T02:22:15.000Z","path":"2017/04/27/outOfMemory/","text":"现象及分析有时候我们会面临一些非常情况的现象，没有异常的情况下进程无缘无故的退出，无法写如日志文件。非常奇怪的错误抛出在终端。 这个时候就需要查看一下系统日志 kern.log 了。 1234567891011121314MAIN kernel: [17832.300370] [&lt;c1090380&gt;] ? oom_kill_process+0x60/0x201MAIN kernel: [17832.300408] [&lt;c10908fd&gt;] ? __out_of_memory+0xf4/0x107MAIN kernel: [17832.300445] [&lt;c109096a&gt;] ? out_of_memory+0x5a/0x7cMAIN kernel: [17832.300482] [&lt;c109322c&gt;] ? __alloc_pages_nodemask+0x3ef/0x4d9MAIN kernel: [17832.300522] [&lt;c109460d&gt;] ? __do_page_cache_readahead+0x98/0x16bMAIN kernel: [17832.300562] [&lt;c10946f4&gt;] ? ra_submit+0x14/0x18MAIN kernel: [17832.300597] [&lt;c108ec9a&gt;] ? filemap_fault+0x16d/0x2e6MAIN kernel: [17832.300634] [&lt;c10a0c9a&gt;] ? __do_fault+0x53/0x3fbMAIN kernel: [17832.300670] [&lt;c10a2f56&gt;] ? handle_mm_fault+0x4d1/0xa22MAIN kernel: [17832.300708] [&lt;c1144ae3&gt;] ? copy_to_user+0x29/0xf8MAIN kernel: [17832.300745] [&lt;c10c6b9a&gt;] ? poll_select_copy_remaining+0xbd/0xd9MAIN kernel: [17832.300785] [&lt;c12830a8&gt;] ? do_page_fault+0x2f1/0x307MAIN kernel: [17832.300822] [&lt;c1282db7&gt;] ? do_page_fault+0x0/0x307MAIN kernel: [17832.300857] [&lt;c12815e3&gt;] ? error_code+0x73/0x78 这个时候我们可以发现内存已经不足了。Linux的保护机制在杀内存消耗大的进程。所以会有进程无缘无故的推出。有一些日志是先写到buffer的内存中，然后再调用日志接口把内存中的日志刷到文件中。此时内存已经不足了，所以内存中已经写不进去了。最终我们看到的现象就是写不到文件中。 解决办法内存确实不足最简单的办法就是直接使用 top 工具。使用Memory usage的排序方式，实时查看进程的内存占用情况。查看哪个服务占用了非常大的内存空间。检查一下为什么占用的内存空间非常大。是不是真的需要。 内存泄漏使用 valgrind 的工具运行程序检测内存释放出现泄漏。","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"TCP 握手","date":"2017-03-28T13:44:05.000Z","path":"2017/03/28/tcp-handshark/","text":"tcp 报头的各个字段的作用想象一下自己去设计一个TCP协议，最中的是保证可靠性。因为每个报文都是要包含这些字段，所以你要怎么保证它的简洁性，不浪费资源。 12345678910111213141516source port: 源端口destination port: 目标端口sequence number: 序号，每一个TCP报文段都会有一个序列，序列号字段段值其实是本报文段所发送段第一个字节的序号，通过序号来确保服务的可靠性和有序性。ack number:确认号Data offset:数据偏移Reserved:保留字段URG(urgent)：紧急指针ACK ：确认字段 PSH：推送字段RST：复位字段SYN：同步字段FIN：终止字段Windows size：窗口大小checksum：检验和Urgent pointer：紧急指针options：选项 tcp 三次握手为什么tcp握手需要三次？这个保证了什么东西？ 客户端发送一个 SYN 给服务端。 服务端返回一个ack和syn给客户端确认。 客户端在返回一个ack确认。tcp连接建立。 如果只有两次握手会怎样？客户端发送了一个连接请求的SYN，但是由于网络问题，以至这个连接释放之后才到达服务端，这时候服务器发送 ack 和 syn 给客户端。如果此时就建立连接，由于客户端已经废弃了这个 SYN，所以这个连接客户端什么都不会发送，白白浪费了资源。 DDoS攻击的也有相似的原理 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 tcp 四次挥手 客户端发送一个 FIN 给服务端 服务端发送一个ACK 确定 服务端再发送一个 FIN 接收服务端的连接 客户端发送 ACK 确定后关闭连接 半连接的时候是怎么处理的？为什么要四次握手？time_wait 的作用是什么？危害是什么？ tcp 连接是全双工的，所以一边发送FIN，都需要另一边 ACK 确定。","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"apache多种debug调试方式","date":"2017-03-22T12:02:01.000Z","path":"2017/03/22/apache-debug/","text":"将正在测试的机器上都打开 coredump，等待重现 在linux系统中执行 ulimit -c unlimited 配置文件中添加 CoreDumpDirectory directory 尝试 valgrind 追踪内存错误 valgrind –tool=memcheck –leak-check=yes –show-reachable=yes –error-limit=no apache strace 调试 strace -f -p pid 尝试用 gdb 启动，等待重现 使用gdb启动服务，直接run，等待进程崩溃 apache信号调试 gdb attach进主线程或者需要的线程 breakpoints continue 访问服务或者发信号 gdb接收信号，然后continue 调试","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"水墨画的扩展","date":"2017-02-15T01:02:05.000Z","path":"2017/02/15/wash-painting/","text":"高与远 水墨画的山水图的结构是非常紧凑的,仿佛有人在极目远望，所有的东西都压缩在一起，视线越远，山峰就变得越高。 层次 水墨虽然都是黑色的，但是浓与淡将空间区分开来，在表现早晨的水雾的时候，效果尤其明显。一些清晰可见，一些若隐若现。 维度 将这些山水画45度角摆放的时候，会产生一种奇艺的效果，仿佛二维的图形有了三维的效果。山水变得立体起来。 时间 仿佛整个世界凝聚于这个瞬间，这个瞬间的所有变化在意想不到的瞬间出现，然后凝聚。","tags":[{"name":"Think","slug":"Think","permalink":"https://trree.github.io/tags/Think/"}]},{"title":"thread","date":"2017-02-12T06:57:05.000Z","path":"2017/02/12/thread/","text":"12只要我时间了，我就把这本书看完。如果我有很多钱，我就要去全世界旅游。 总是喜欢信誓旦旦的对别人说着一些话，不知道最后多少人达成了目标。就像小时候想要的那个模型。现在可以轻而易举的买下小时候的想要的任何东西。可是突然失去了对这件事情的乐趣。时间与环境的变化，那么事情本事早就失去了它原本的意义。 太多时候总喜欢用如果只要达到什么条件，那么我就要做什么。喜欢把生活一步一步的规划，达到一个目标之后，才开始进行下一步。如果有一步陷入了困境，那么就一直阻塞在那一步。 计算机人员在解释多核的时候，喜欢用一个人在多项任务之间切换得够快，那么像是在同时处理多件事情一样。但是我们不能像孙悟空或者技术总监一样分身。分配人员同时处理不同的事情。 但是可以像线程一样。在保证主线程正常运行的时候，使用多线程的方法，从现在慢慢就开始做自己喜欢的事情。但是也要保证线程安全。 refer: thread","tags":[{"name":"Tech, Think","slug":"Tech-Think","permalink":"https://trree.github.io/tags/Tech-Think/"}]},{"title":"问问题","date":"2017-02-08T10:23:00.000Z","path":"2017/02/08/ask-question/","text":"在问问题之前不需要问在不在，一般上班时间并且头像是亮着的话人是在的。 这个项目的背景是怎样的？问题是在什么时候产生的，是在部署的时候还是网关在运行的时候产生的，如果是网关在运行的时候产生的，那么在之前有没有进行过什么操作。需要能够描述问题产生原因。而不是只是描述一个结果。 问题能否重现，重现的方法是什么，如果不能重现，说明不能重现的理由。（在自己电脑中使用虚拟机搭建网关的环境） 提供网关的版本号，升级包记录等相关信息。 需要时要能够使用tcpdump到网关后台抓包。平时需要学会使用tcpdump和wireshare等简单的工具。 简单的学会一些linux的命令行，vim等操作。 问问题之前先参考wiki或者FAQ上是否存在类似的问题。 学会怎么问问题。提供以上信息，并且能够一次性把问题描述清楚。","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"Apache内存管理","date":"2017-02-06T11:47:33.000Z","path":"2017/02/06/apache-pool/","text":"Apache 提供了自己的内存和资源管理方式，称作内存池，内存池在apache中任何一个阶段被使用，所以也被外部模块使用。内存池可以管理内存，Sockets 和进程等服务系统所有的资源。 内存池的使用可以降低程序设计错误的可能性。在程序中如果由于疏忽或错误造成程序未能释放已经不再使用的内存，造成内存泄露。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费，其它的程序就不能够再使用这个内存段。 客户端的程序因为运行不是非常长时间，退出后操作系统会自动释放资源，所以不是造成太大的危害。但是在服务端端程序由于长期运行，即使是一点地内存泄漏由于长期内存泄露造成服务端的崩溃。 尤其需要注意Sockets。如果建立了一个Socket，但是在业务完成时没有释放它，那么其它的程序就不能使用这块内存。这些不断建立但是未释放的Sockets会造成内存，CPU被占满。此时服务端一定会崩溃。许多服务端现在基本都是以多线程或者多进程的方式工作，这些进程或者线程如果不按设计退出只能被管理员中断。如果一个程序不停止运行，那么服务端端资源会被立马占满并且崩溃。 随着内存池的使用，开发者可以在一个已知生命周期的内存池中使用内存，sockets和进程。一旦这个内存池被摧毁，那么所有的资源都会自动的释放。这样就只有一些仔细考虑后额外的例程才会需要考虑释放内存的事情。这样就变得更简单明了，减少了开发者的负担。 重要的是，内存池可以提升服务器的性能。通常一个程序使用和释放内存，由于系统需要从虚拟内存中分配和释放内存，这些会造成许多的开销，这将显著的降低性能。并且，不管请求了多少内存，系统通常分配一个最小数量的空间。那么这将造成许多小的内存空间被浪费。经常这样做的话，那么你需要关注这些小内存的价值了. 内建池和生命周期 Apache内建的内存池都有不同的生命周期，如上图所示，该图描述了池的继承的层次结构。pglobal存在于服务器的真个运行周期，pchaild存在于整个子虚拟机主机的生命周期，pconn是每一个连接的生命周期，preq是每一个请求的生命周期。通常开发者使用最小的生命周期最小存储空间最小存放数据。 如果开发者需要一个非常大的内存空间，而且没有一个合适生命周期的内存池。一个任意内建池的子池可以被创建。程序可以像内建池一样使用这个内存池，也可以在不需要这个内存池的时候释放它。如果忘记了释放这个内存池，那么在它的父池被释放的时候它会被自动释放。释放pglobal的时候，所以的子池都将被自动释放。每一个连接池是子服务池处理连接，所有的请求池都是对应了连接池。 内存池的内部结构 如上图所示，一个池内部链接了一系列的子池，数据块，进程和回调函数。如果需要分配内存需要使用预定义的函数。这些函数不只是分配内存，并且也可以释放内存。同样的进程也可以通过内存池建立，内存释放的时候进程结束。此外，每个池可以保存关于在销毁所有存储器之前被调用的函数的信息。这样文件处理程序和套接字都可以注册一个池去销毁它。 当一个内存池被销毁的时候，apache首先回调清理函数。所有注册的文件句柄和Sockets将被关闭。之后，池讲终止所有的注册和进程。这些结束之后，数据块就被释放。通常apache并不是真的释放被其它程序使用的内存。而是将它从池中删除，将这段内存放入空闲的内存块中。这样就将分配和释放内存的消耗降至最低。内核将立即分配这些空闲的内存。只有在池中所有的内存都用完时才需要分配新的空间。 refer: Memory_resource","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"重复","date":"2017-02-05T14:36:33.000Z","path":"2017/02/05/repetition-work/","text":"想想你去年重复了哪些工作，哪些工作占用了你的大量时间，技术支持的时候是对方没有描述清楚问题，还是自己没有理解好问题。是对方在现场操作太慢，还是自己提供的文档不够齐全。 在工作的时候哪些场景会让你不开心，不开心的原因是什么，是因为事情本身，还是这种交互之间占据了太多时间，是对方的原因，还是自己没有讲清楚的原因。 什么场景下你会感到非常的烦躁，是因为工作事情本身的原因，还是没有休息好的原因。 什么东西会影响你工作的效率，突然的电话的打扰，消息，邮箱的打扰。身边同事的打扰，什么打扰你可以忍受，什么打扰你不可以忍受。什么东西会促进你的工作效率，在工作的时候听音乐可以促进你的工作效率吗？在什么情况下你需要音乐去促进你的效率。还有什么硬件或者软件可以促进你的效率，你有争取去改进你的原有的什么方式吗？","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"人头马身","date":"2016-10-25T00:48:22.000Z","path":"2016/10/25/20161025/","text":"(一) 来到这个城市已经十年，时间在指尖上溜过，却什么也不曾留下，一无所有的来，可是比到来变得更加得一无所有，来的时候以为能够在这个城市留下辉煌，可是我是留下来，也把我的卑微也留下。如果我手中有一把剑，我会成为一位剑客，纵横四海，无所畏惧，可是我手中没有剑。如果我会跳舞，我会在月光下，在舞台中央，在所有的目光中灼灼生辉，可是我不会跳舞。如果我活在魏晋，我会成为一个放浪形骸的人，饮觞取酒，或宠辱不惊，或尽情悲痛，可是我活在不一样的时代。如果，如果，我只是一个普普通通的一个人，什么也不会，什么也做不了。如果我手中有一个键盘，是的，我手中现在只剩下键盘。看着屏幕，顾影自怜。我是一名程序员，版本更新之后，旧的代码已经面目全非。时间也就变得面目全非。 你是否感觉到，这个世界每时每刻都在变化，在你闭上眼的那一刻，在你早上醒过来的那一刻，你已经转换到了另一个时空，细微的变化并没有让你察觉，可是在睁开眼睛的那一刻，你是否有一丝的恍惚?你不能同时存在一条河里两次，你不动，水已经动了，你跟着水动，位置已经变了。我已经变得越来越恍惚，越来越心不在焉，头脑昏沉。我的意志感觉不受束缚，手也已经开始不受控制。“你好，我叫陈晓，来自你的平行世界。”仿佛一瞬间清醒过来，感觉到恐惧，难道那个世界的科技已经发达到了这种程度。不知道为什么那个平行世界会找上我,难道是他能够感受到每个时间线，在所有的时间线上选择了我。或者我们身上有着一个相同的时间节点。记得那是一个非常普通的的晚上，我坐在我的电脑前面，可能那个时候我意外的成为了一个叠加态，在理论物理和工作两个态之间做选择。我的世界坍塌在工作上面，而另一个我坍塌在做科研，而且是理论物理的方向。“如果你能够看到，那么在明天凌晨2点到xx区xx路xx广场见面。” 刚上出租车，出租车司机就开始自说自话了，聊东聊西。他们是这个城市半夜的孤魂，永远也找不到自己的出口。接着就开始抱怨：“那些男司机每天下班回家，家里都会做好饭，喜好衣服，把一切都弄好，我们呢？休息的时候还要早起洗衣服做饭，拖地板。永远没有休息的时候。”“其实我还算幸运的了，我载完你去洗车，然后去交接车子之后就可以回家了。我的一个同事就辛苦的多了，好不容易在老家盖起了房子，贷款还没还清，老公就检查出来癌症，平常她的老公也没有对她怎么怎么好，可是却要一起去承担这种事情。看她的样子都老了好多。”她没有讲完我就到目的地了，可是感觉她永远也有讲不完的故事，然后对着不同的人讲着相似的故事。 下车之后12点多了，在这个城市中游荡，此时正是盛宴之后。商厦这时候都已经关门，却依然发出艳丽的霓虹灯。路灯这时候撑起昏黄的小伞，清冷的空气扑面而来。这时候路上已经没有什么人，可以听见脚底与路面的摩擦的声音。呼吸的声音。月亮挂在高远的天空中。此刻仿佛有着黑洞在靠近，将一切都吸引过去，包括光，内心也变得恐惧起来。 静谧一下子被打破，所有的东西都动了起来。一切都开始扭曲。所有的东西都长出了脚，高楼缓慢笨拙的移动着，路灯开始奔跑起来，远方传来响亮的嘶吼声。仿佛一只蚂蚁在人群之中一样，他们走动，巨大的脚掌在空中移动，明与暗不停的交错，我却也无处可躲，我是如此的微小，他们也感受不到我的存在。 在慌乱中我呆滞地站在原地，看着一切。 (2) 达达的马蹄，一匹马在暗黑的玻璃上，在流动的水上飞跃。它停在我的面前，载起我，飞驰而上，流动的城市形成了一个八卦阵的形状。一辆辆车子在其中左突，右冲，可是总是在这个城市中打圈。 是的，他的人生毫无价值，你看，他蜷缩在那个角落中，衣衫褴褛，比一张废纸还不如。 你看那个齿轮，他天生就是一块齿轮吗？你知道齿轮的生产过程马？他们本是一块铁，因为特殊的需要，经过高温溶成铁水，然后浇筑在模版上。 来到镜子面前，仔细的端详着这张脸，这么熟悉，我仔细的看着，仿佛看着一个非常熟悉是字一样，突然间变得非常的陌生，文字好像突然有了形象，而这张脸仿佛逐渐变成了一个符号，没有什么特点，没有美丑，没有颜色，只剩下一个粗劣的线条。另一面镜子就竖在对面，瞬间这张脸被复制了无数遍， 你是谁，你在干什么，你想要什么？","tags":[{"name":"人头马身","slug":"人头马身","permalink":"https://trree.github.io/tags/人头马身/"}]},{"title":"深秋","date":"2016-10-22T09:28:47.000Z","path":"2016/10/22/last-Fall/","text":"北方的气温已经降了下来，有必要套一件大衣了。南方开始下雨，连门都出不了，不然就要拖着一身的风雨回来了。深秋时节最美，这是生命的大繁华的时刻。不宽的水泥地，青色的矮墙，燃烧的银杏树，点燃金色的光芒，虽是下午，但是前方布满薄雾。显得非常的深远。雨巷还是随处可见，丁香一样的姑娘早已经离去，雨水依然滴答这石板。秋天是一个收获的季节。桔树，葡萄树经过一个夏天的生长，现在人们欣喜的把果子采摘下来，成为了人们口中甜美的美食。 深秋了。","tags":[]},{"title":"自测网关安全性","date":"2016-10-20T09:28:16.000Z","path":"2016/10/20/gateway-s-safe/","text":"网关的主要作用是转换原B/S，C/S系统的协议，将原来未加密的协议转换成加密的协议。在这里网关将未加密的HTTP协议或者TCP协议转换成SSL协议。任何一个增加的系统都会增加安全性的问题，作为一款加密产品，那么它更应该注重自生的安全性问题。 IP和端口扫描(nmap，netcat) 对访问用户压测，看看有大量用户访问时是否会断开连接(burpsuit, ab, loadrunner) 查看每一个连接中的关键数据是否加密 传输的数据是否加密 对文件上传和下载是否满足用户权限的要求，是否保护 对shell和sql是否防止注入 对网关的系统和服务器进行安全性扫描","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"一个叫天南，一个叫地北","date":"2016-10-17T09:24:02.000Z","path":"2016/10/17/wood/","text":"南方总是温润的。南方的一半是水组成的，水的一半给了人，另一半却给了眼睛。到那里都是水波荡漾一片。南方的早晨总是在泼绿中蒙着一层纱。犹抱琵琶半遮面的。南方的雪是温和的，滋润美艳之至了，这时候南方就是一幅留白的山水画了，南方是一棵柳树，她就那样站在那里，微风轻拂着柳条，岁月静好。南方的冬天却也是暴戾的，毫不留情的把你的脚放到冰中，喜欢着南方的好，忍受着南方的暴戾。 懂得南方却不懂北方。一个叫木头，一个叫马尾。 -———记于北方途中","tags":[{"name":"Caprice","slug":"Caprice","permalink":"https://trree.github.io/tags/Caprice/"}]},{"title":"自述Tcp超时与重传","date":"2016-10-16T03:02:39.000Z","path":"2016/10/16/Net-Tcp/","text":"将tcp的超时与重传的文档太多了，我也是从tcp/ip详解这本书上学习了。所以如果你对这个不熟悉，希望你先看书，不然基于我自己的理解，很容易让人误解。但是如果有大神，如果有什么写错，或者理解错误的东西，希望指出，不胜感激。 tcp的超时设置是为了防止网络问题和节省时间之间的一个平衡，如果不设置超时，当一个ack没有获取，那么此时直接返回网络错误。重传是为了防止偶然的网络问题。超时的时间间隔大部分都是指数间隔，而不是线性的。 tcp的所有超时的地方，从第一个客户端读取 syn ＋ ack 超时，超时与重传connect 超时响应超时读写超时timewait超时 超时重传机制哪些会超时，哪些直接发送reset断开连接或者超时多长。","tags":[{"name":"Tech, Net","slug":"Tech-Net","permalink":"https://trree.github.io/tags/Tech-Net/"}]},{"title":"一个偶然的arp网络错误","date":"2016-10-16T03:02:27.000Z","path":"2016/10/16/Net-arp/","text":"在网络的使用中这个是我们比较少关注的一个协议，它是用来查看ip地址和mac地址的对应关系。 一般情况下网络问题很少出现在这个地方。而且如果查看这个值出现问题的时候，一般是上层的协议出现了问题，或者就是整个网络出现了问题。 但是今天需要讲述一个比较特殊的情况下arp的网络问题。问题的起源是我使用openvpn搭建一个client-to-client 的环境。就是使用一台openvpn的服务器，然后使用两台openvpn的客户端去连接openvpn的服务器。我在openvpn中配好 client-to-client 选项后，然后两台openvpn的客户端可以ping通服务端，也可以看到下发的策略。但是在两台客户端的中相互ping对方，却是不通的。查看ip和tcp，都是正常的。没有检查到异常，但是一直都是不通的。 最后没有办法，只能按照网络协议层一层一层的往下去分析。在windows的cmd下，查看路由 route print。路由正常。ip和端口正常，ip层和tcp层都是正常的。使用arp -a的指令，得到 1234arp -a172.16.0.2 ether 00:ff:90:4e:20:cc C tap0172.16.0.3 ether 00:ff:90:4e:20:cc C tap0 172.16.0.0/16 是虚拟IP的地址，第三项是对应的Mac地址，所以到链路层之后，有两个相同的mac地址。所以从mac地址转换成IP地址的时候丢失了IP地址。所以一直访问不通。 为什么会有两个相同的mac地址呢？第二个openvpn的客户端是直接复制第一个openvpn的虚拟机。所以出现了两个相同的mac地址。修改其中一个虚拟IP的mac地址之后就可以相互ping通对方了。 如果想重现问题，可以将两个IP地址改成相同的mac地址，查看一下你的那边会出现什么情况。 ###虚拟IP 123arp -a192.168.41.97 ether 00:0C:29:EB:70:DA C eth0192.168.41.92 ether 00:0C:29:EB:70:DA C eth0 有时候我们可以在同一台机器上看到两个IP有相同的物理地址。traceroute 这两个IP都是正常的，可以访问的。没有出现上面不能访问的情况。 MAC destination MAC source Source Address Destination Address(ip/Virtual_ip) MAC destination MAC source 在这种情况下主机中发出的数据中包含了目标地址的IP，所以可以正常到达目标主机。但是如果是两个Mac相同，发送apr的tell数据包的时候，会有两个地方都会响应，那么就会造成Mac地址冲突了。","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"获取Apache信息接口","date":"2016-10-16T03:02:11.000Z","path":"2016/10/16/Apache-Info/","text":"在apache的使用中，如果是一个apache代理服务器，并且使用的证书的话，我们不可避免的需要将从前端和证书中的信息传递给后端处理。一般情况下，我们都是将这些信息绑定在http头中，cookie项中，这样后端比较容易处理。 幸运的是，apache为我们提供了这么一个可选函数，可以任何的一个模块中获取你需要的信息。这个可选函数是在模块 mod_nw_ssl 中定义。 APR_REGISTER_OPTIONAL_FN(ssl_var_lookup); 那么这个可选函数可以获取哪些参数呢？ 前端http头中的信息 ssl的参数，和对应使用的用户证书的各项内容。 连接socket的各项参数 格式化的各种时间 保存在 r-&gt;notes 中的的环境变量 如何找不到key对应的value，则返回空字符串。","tags":[{"name":"Tech, Apache","slug":"Tech-Apache","permalink":"https://trree.github.io/tags/Tech-Apache/"}]},{"title":"困","date":"2016-10-16T03:02:00.000Z","path":"2016/10/16/Trap/","text":"为身所累，为圈所困。 记得有一次和朋友去寺庙玩，因为是在旅游，所以一路都是背着旅行包的。由于那时候宁可信其有，不可信其无。所以到了寺庙都会虔诚的拜拜，不是为了什么。我就一间房一间房的去看，去拜拜。当我来到一座大佛面前时，直接就拜了下去，这时候在这间房子的老师傅说：”施主，拜佛的时候放下你的背包.”犹如当头一棒，在路上已经忘了身上的负担，感觉背包已经和自己融为一体， 昨天去寒山寺，身上不着一物，忽然发现最重的负担是放不下，背包可以放下，可是放不下就如着空气，无影无形中，一个圈，一句话，却轻易的困住了自己。在你最脆弱的时候犹如大山直接压着。我看着金光闪闪的尊者和罗汉，可是我却找不大一个答案。听着钟声，却是对愁。","tags":[{"name":"Caprice","slug":"Caprice","permalink":"https://trree.github.io/tags/Caprice/"}]},{"title":"Apache 超时设置","date":"2016-10-16T03:01:53.000Z","path":"2016/10/16/Timeout/","text":"在apache的使用过程中，我们可以看到许多的超时设置，因为apache是一个web服务器，所以它的超时是包含底层的超时设置，例如tcp协议的。所以这一篇文档包含http，ssl，tcp等协议的超时设置。 timeout tcp读写超时(wait_for_io_or_timeout) t &gt; 0 – read and write calls return APR_TIMEUP if specified time elapsess with no data read or written t == 0 – read and write calls never block t &lt; 0 – read and write calls block keepalivetimeout 在keepalivetimeout时间后没有子请求，断开连接(ap_process_http_connection) proxytimeout 没有设置的时候与 timeout 的一样 RequestReadTimeout（reqtimeout_init） 设置读取http头和http正文最大和最小超时时间 默认值： MRT_DEFAULT_HEADER_TIMEOUT 20 MRT_DEFAULT_HEADER_MAX_TIMEOUT 40 MRT_DEFAULT_HEADER_MIN_RATE 500 MRT_DEFAULT_BODY_TIMEOUT 20 MRT_DEFAULT_BODY_MAX_TIMEOUT 0 MRT_DEFAULT_BODY_MIN_RATE 500 SSLSessionCacheTimeout ssl session 超时时间","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"井","date":"2016-10-16T03:01:46.000Z","path":"2016/10/16/shaft/","text":"村里有一口井每至夜深人静之时总能听见它涌动的声音折磨无法入睡 我在村子里面徘徊村头两座小山村尾两棵大白杨那一口井就藏在村中间 我像一头野牛一样在这里面冲撞我 留着汗奔跑，我将坝台高驻我爬上山，我爬上树不，我不能停歇 我找到这口井了毁灭它，将石头掩埋将热闹覆盖 夜深人静，我听见泉水涌动的声音将石头取出将热闹去除只身跳入这口井中","tags":[{"name":"Caprice","slug":"Caprice","permalink":"https://trree.github.io/tags/Caprice/"}]},{"title":"窗外","date":"2016-10-16T03:01:35.000Z","path":"2016/10/16/Out-of-Windows/","text":"被困在车厢里。车厢因为站票挤满了人，举步维艰，即使能移动，也只是在车厢里，最后还是回到自己的位置。人身上发出的气味，泡面的腐味因不开窗而始终弥漫。有种窒息的感觉。人们聊天的声音，手机叮叮响的声音爆炸在耳边。即使在深夜里，那永不停歇的火车运动的机械声。在深夜的梦里回响。一个人趴在窗上，无事可做，仅仅趴在窗上，在那积满灰尘的窗上。一心望着外面。望着窗外。转过一座山，并行的湖。天地的蓝天白云相接。旋转而起的树木，碧波荡漾的竹林，其间点缀无数点点星星。九万里的大鸟在云层之外翱翔。火车在盘着山，就如此彳亍着，有时可以看见火车外有人在奔跑，引起车里人的嘲哄声，但马上连他的背影也看不见了。就这样一直望着窗外一天一夜，期间不断的食品叫卖声与引起的喧闹嘲杂声不闻不问。突然有种莫名的冲动，毅然决然的跳下火车，投向那森林的最深处，走向海的绝渊中，飞向那无人触及的圣地。雨打在窗外，凝聚，演绎着千姿百态，最后回于水中，雨仅仅只是水，但他或许会变成气，变成雾，雪，血。突然有一刻，仅仅那一刻，从窗外投射来的一缕阳光，透过窗，透过身体，照在心上。","tags":[{"name":"Caprice","slug":"Caprice","permalink":"https://trree.github.io/tags/Caprice/"}]},{"title":"PHP Session超时设置","date":"2016-10-16T03:01:02.000Z","path":"2016/10/16/PHP-Session/","text":"PHP控制session的方法环境：PHP的session控制使用crond定时检查debian3， ubuntu14.0.4 PHP的session文件保存在 /var/lib/php5 中，如果是使用cookie保存session的方法，可以在浏览器中查看cookie，查看两个值是不是一样的。如果你手动清除这个文件，登陆页面马上放回到你需要跳转的页面。所以对session时间的控制就是对删除session文件时间的控制。 删除session文件是使用首先查看 /etc/cron.d/php5 的文件 09,39 root [ -d /var/lib/php5 ] &amp;&amp; find /var/lib/php5/ -type f -cmin +$(/usr/lib/php5/maxlifetime) -print0 | xargs -r -0 rm 从这里可以看出系统定时检查session文件的修改时间，一旦超出maxlifetime，就将它删除。所以最后的控制就在 /usr/lib/php5/maxlifetime 中。 我们查看这个文件做了什么事情这个文件中默认最大超时时间为 1440 秒，然后与 /etc/php5/*/php.ini 的session.gc_maxlifetime 时间比较，哪个大取哪个值。在 /etc/php5/*/php.ini 中默认时间也是 1440 秒，所以非常的麻烦修改三个文件。 最简单的设置session超时时间直接修改 /usr/lib/php5/maxlifetime echo $time 这个 $time 就是你设置的超时分钟。","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"空城","date":"2016-10-16T03:00:50.000Z","path":"2016/10/16/City/","text":"早上醒来，我突然发现自己得了空人症，这个城市还是原来的城市，这个城市的运作还是按照原来的方式，可是在我的眼里看不到一个人，和这个人周边的东西。仿佛这个世界上的人都消失了，只剩下机器在运作。 你可以感受到，在街上还是有那么多的车在开，可是你看不到一个人，地铁仍在开，你可以悠闲的坐在任何一个位置，因为没有人跟你抢，尤其是在中国这个大城市中，感觉尤为强烈。 你就这样一个人走在这个空空荡荡的大街上，眼中空无一人。","tags":[{"name":"Caprice","slug":"Caprice","permalink":"https://trree.github.io/tags/Caprice/"}]},{"title":"夏天","date":"2016-10-16T03:00:43.000Z","path":"2016/10/16/Summer/","text":"有时候会突然的想起你，我尽力去回想你的脸，你的笑容，我们在一起的每一个细节。手机里面还有你的号码，你的照片。可是这些都仿佛是一个遥远的梦，现在想来如此的不真实。我一直埋得很深，我总是很忙的样子。不愿意停下来，因为一旦停下来，仿佛一下子掉入一个无底的深渊。","tags":[{"name":"Caprice","slug":"Caprice","permalink":"https://trree.github.io/tags/Caprice/"}]},{"title":"剑","date":"2016-10-16T03:00:36.000Z","path":"2016/10/16/Sword/","text":"如果我手中有一把剑，我会成为一位剑客，纵横四海，无所畏惧，可是我手中没有剑。如果我会跳舞，我会在月光下，在舞台中央，在所有的目光中灼灼生辉，可是我不会跳舞。如果我活在魏晋，我会成为一个放浪形骸的人，饮觞取酒，或宠辱不惊，或尽情悲痛，可是我活在不一样的时代。 如果，如果，我只是一个普普通通的一个人，什么也不会，什么也做不了。 给我一把剑，我却只会伤了别人，也伤了自己。即使我会跳舞，却也会踩到你的脚，走错了步。即使我回到那个时代，我依然会退缩，退缩到一个安全的地带。我回不到过去，也没有如果。","tags":[{"name":"Caprice","slug":"Caprice","permalink":"https://trree.github.io/tags/Caprice/"}]},{"title":"Library20160717","date":"2016-10-16T03:00:28.000Z","path":"2016/10/16/Library/","text":"我看到你表现得很强势，你总是不让人质疑你。你的表情冷漠，你自负。你说你是一个天才。只是一个没人发现的天才。可是，我却看到你的逃避，孤独，自卑，你一直在逃避自己，你害怕真实的你，你身处于海上，在一条小船上，你并不是一座孤岛，你只是漂流的一条小船而已。风来，你就吹风，随风而走，雨来，你就在海上写字。你就这样直接地暴露在这个海上，唯一的陪伴就是你的海面的倒影，可是这个只是使你更加的顾影自怜而已。 忽然什么都不想做，就这样毫无目的的敲打着键盘，它会带我到哪里呢？现在像是陷入了一个低谷中一样，看不到希望，明知道自己是一只井底之蛙，却也无法爬出这个绝壁。这只青蛙也许是悲哀的，其他的青蛙都能够很安然的活在这个世界中，从不关心这个天，这个天外有什么？可它偏偏看到一只天鹅飞过，这片天就变得不太一样了。它明知道这片天不只是这么小，因为它看过有天鹅飞过，它看见过的是别的从不在乎的。它们从来就不关心这些。 不知道是杜撰的还是一个真实的故事，一位智者让他的学生经过一个花园，不回头的情况下获取一样你最喜欢的东西。学生面对一开始的大麦穗的时候总是在想后面总会有更大的。或者在犹豫的那一个刹那，身体已经跨过去了。就像另一个智者告诉的，下一个总是最好的。然后在自我安慰中在不经意间又跨过几步。我只走了几步，我以为我的最重要的东西是比任何人都要快的到达终点，所以我不愿意去等待，我总是急不可耐的就出发了。然而我觉得我已经变得十分的老迈了。我曾经为为没有尝过苹果而失望，现在尝过苹果变得更加的失望，因为我失去了我最喜欢的那个苹果。 讲故事总是非常的容易和轻巧，可是朝菌不知晦朔,蟪蛄不知春秋，即使我们知道故事的结局是怎样的，可是依然无法改变。","tags":[{"name":"Caprice","slug":"Caprice","permalink":"https://trree.github.io/tags/Caprice/"}]},{"title":"早开的紫藤","date":"2016-10-16T03:00:15.000Z","path":"2016/10/16/flower/","text":"四月初，我看见路边的紫藤萝已经开了。这种花开像瀑布一样，倾泻而下，一朵一朵鲜活的像一个个笑容一样， 可是我们去得太早，花开几多，零零散散。","tags":[{"name":"Caprice","slug":"Caprice","permalink":"https://trree.github.io/tags/Caprice/"}]},{"title":"SSL Session 和 Session Tickets","date":"2016-10-16T03:00:00.000Z","path":"2016/10/16/SSL-Session/","text":"背景在对http和https性能比较的时候，可以发现http性能比https高出几个数量级。因为https使用了tls/SSL协议，客户端与服务端进行ssl握手，在握手的时候需要进行密钥协商，密钥交换，身份认证等过程，尤其是在这中间必须要传递证书确定身份。 为了在安全和性能之间寻找一个平衡点，SSL Session 是解决这个问题的一个方法。SSL Session的安全性是建立在必需要获取整个 Session ，只是获取明文传输的的Session ID 是无法握手成功的，Session是缓存在客户端中，要窃取客户端的Session是非常困难的。 SSLSessionTickets在apache中是默认开启的。如果需要关闭必须加上 SSLSessionTickets Off。 123456789101112131415161718192021Client Server ClientHello (SessionTicket extension) --------&gt; ServerHello (empty SessionTicket extension) NewSessionTicket [ChangeCipherSpec] &lt;-------- Finished [ChangeCipherSpec] Finished --------&gt; Application Data &lt;-------&gt; Application Data 测试session ticket重用 openssl s_client -connect host:port -sess_out session_file openssl s_client -connect host:port -sess_in session_file 第一次访问的New session 1234567891011121314151617181920212223242526272829303132333435New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384Server public key is 2048 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES256-GCM-SHA384 Session-ID: 596B3F7202A4E299F7EACF4C73818ED048085DFEA6DF31780C225C5D3045DD9A Session-ID-ctx: Master-Key: E96BA7797E9415D0C052F5212BEC6F9D009877C277535CB7B121B091BF24AA1FA06FD2FABE9E59EDBA6499412CD404B1 Key-Arg : None PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 300 (seconds) TLS session ticket: 0000 - a0 b1 ee 17 03 57 df 58-f0 fc 7e 34 8e f7 c1 13 .....W.X..~4.... 0010 - 7a af d5 05 49 ea 1c 34-07 01 6e 08 f2 92 90 3f z...I..4..n....? 0020 - e0 82 f9 c3 5f 27 88 98-fc 2e d3 36 bf d0 71 c3 ...._&apos;.....6..q. 0030 - c2 41 93 dd ac ba 80 15-9c 6f c2 07 ac 28 0f a7 .A.......o...(.. 0040 - 3a 1a 0e 58 74 09 36 0b-ce fe 52 95 6b b6 f1 f7 :..Xt.6...R.k... 0050 - dd 75 b8 04 8e ae 08 65-c5 e0 bb 49 0c f6 8a 9f .u.....e...I.... 0060 - 51 f1 36 44 35 a3 1d 07-dd 3a 48 63 4a e7 74 a4 Q.6D5....:HcJ.t. 0070 - c5 3e 0a 1e 5a fd 10 66-18 0f ae e2 c0 87 77 3c .&gt;..Z..f......w&lt; 0080 - 32 73 68 12 4e 89 76 aa-0f c3 99 90 96 36 2a 40 2sh.N.v......6*@ 0090 - d2 60 a6 6d 8d da a6 46-13 16 89 56 a0 28 f1 2c .`.m...F...V.(., 00a0 - 9c 7d 21 df 05 b6 1e 7c-99 cb 7b 5a a8 97 f3 72 .&#125;!....|..&#123;Z...r 00b0 - ba 1d 6d 7e a3 99 bc 4b-a8 81 a6 7a b9 e3 9e d4 ..m~...K...z.... Start Time: 1490175208 Timeout : 300 (sec) Verify return code: 19 (self signed certificate in certificate chain) 使用session访问 1234567891011121314151617181920212223242526272829303132333435Reused, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384Server public key is 2048 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES256-GCM-SHA384 Session-ID: 596B3F7202A4E299F7EACF4C73818ED048085DFEA6DF31780C225C5D3045DD9A Session-ID-ctx: Master-Key: E96BA7797E9415D0C052F5212BEC6F9D009877C277535CB7B121B091BF24AA1FA06FD2FABE9E59EDBA6499412CD404B1 Key-Arg : None PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 300 (seconds) TLS session ticket: 0000 - a0 b1 ee 17 03 57 df 58-f0 fc 7e 34 8e f7 c1 13 .....W.X..~4.... 0010 - 7a af d5 05 49 ea 1c 34-07 01 6e 08 f2 92 90 3f z...I..4..n....? 0020 - e0 82 f9 c3 5f 27 88 98-fc 2e d3 36 bf d0 71 c3 ...._&apos;.....6..q. 0030 - c2 41 93 dd ac ba 80 15-9c 6f c2 07 ac 28 0f a7 .A.......o...(.. 0040 - 3a 1a 0e 58 74 09 36 0b-ce fe 52 95 6b b6 f1 f7 :..Xt.6...R.k... 0050 - dd 75 b8 04 8e ae 08 65-c5 e0 bb 49 0c f6 8a 9f .u.....e...I.... 0060 - 51 f1 36 44 35 a3 1d 07-dd 3a 48 63 4a e7 74 a4 Q.6D5....:HcJ.t. 0070 - c5 3e 0a 1e 5a fd 10 66-18 0f ae e2 c0 87 77 3c .&gt;..Z..f......w&lt; 0080 - 32 73 68 12 4e 89 76 aa-0f c3 99 90 96 36 2a 40 2sh.N.v......6*@ 0090 - d2 60 a6 6d 8d da a6 46-13 16 89 56 a0 28 f1 2c .`.m...F...V.(., 00a0 - 9c 7d 21 df 05 b6 1e 7c-99 cb 7b 5a a8 97 f3 72 .&#125;!....|..&#123;Z...r 00b0 - ba 1d 6d 7e a3 99 bc 4b-a8 81 a6 7a b9 e3 9e d4 ..m~...K...z.... Start Time: 1490175208 Timeout : 300 (sec) Verify return code: 19 (self signed certificate in certificate chain) session-id 重用测试 openssl s_client -connect host:port -reconnect 1234567891011121314151617181920212223242526272829New, TLSv1/SSLv3, Cipher is AES256-SHAServer public key is 2048 bitSSL-Session: Protocol : TLSv1 Cipher : AES256-SHA Session-ID: 405763BDF7B0AFC42E44F865DFCB277167E347CCC393B374544671FC161570D5 Session-ID-ctx: Master-Key: 566E880A4F167098ECFE1EC4230B4BF7A932211DBDE24033976C90BCA7D04813457E7D395D2FEF19B12175181C070C55 Key-Arg : None Start Time: 1490175819 Timeout : 300 (sec) Verify return code: 19 (self signed certificate in certificate chain---drop connection and then reconnectCONNECTED(00000003)---Reused, TLSv1/SSLv3, Cipher is AES256-SHASSL-Session: Protocol : TLSv1 Cipher : AES256-SHA Session-ID: 405763BDF7B0AFC42E44F865DFCB277167E347CCC393B374544671FC161570D5 Session-ID-ctx: Master-Key: 566E880A4F167098ECFE1EC4230B4BF7A932211DBDE24033976C90BCA7D04813457E7D395D2FEF19B12175181C070C55 Key-Arg : None Start Time: 1490175819 Timeout : 300 (sec) Verify return code: 19 (self signed certificate in certificate chain)--- refer:openssl cookbook","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"Apache缓存过滤及其原理","date":"2016-10-16T02:59:47.000Z","path":"2016/10/16/Apache-Cache/","text":"背景apche 提供了cache的功能，能够将应用服务端的资源缓存在apache中，尤其是在apache是代理服务器，原始服务器的物理距离非常远的时候，性能就能够非常好的体现。 所以此时的网关服务器也可以作为缓存服务器使用。因为公司使用的是apache2.0系列的。所以在它那里发现它只支持URL的strcasecmp匹配。所以匹配所有的URL为 ‘/‘。但是我们希望提供普遍的过滤功能。只缓存 .jpg,.png,.css 等不变的内容。而将经常需要改成的 .html , .js 不缓存。 所以我们的方案是在 cacheenable 中增加一个可变参数，正则配置的参数。当正则匹配存在的时候，只使用正则批准，如果不存在，则使用原来的url的匹配。保证与原2.0的兼容性。 网关cache原理 不存在缓存的时候，客户端发送请求给网关，网关再向后端发送请求，然后返回给网关，网关返回给客户端。 存在缓存的时候，首先，mod_cache将是一个URL映射模块，也就是说，如果一个URL已经被缓存并且这个缓存尚未失效，该请求将由mod_cache直接处理。这也意味着在处理一个请求时通常还要发生的其他阶段：比如权限验证，mod_proxy或mod_rewrite处理的阶段，将不会发生。网关可以直接返回内容给客户端。 cache 类型mem基于mem缓存,在高级设置中已经实现，填入mem会产生配置如下12345CacheEnable mem MCacheSize 4096MCacheMaxObjectCount 4MCacheMinObjectSize 1MCacheMaxObjectSize 1048576 disk基于disk缓存，需要另外填写配置文件12345678CacheDefaultExpire 3600CacheEnable disk /CacheRoot /tmp/apacheCacheCacheDirLevels 3 CacheDirLength 4CacheMaxFileSize 1048576CacheMinFileSize 10 ramdisk实现方案基于disk缓存，将CacheRoot设置为内存盘目录，开机的时候自动建立整个内存的10%用于存放缓存。​ 缓存文件在CacheRoot的目录下，生成带后缀的缓存文件.data 和 .header。可以使用strings命令查看文件.data保存了缓存文件内容.header保存了缓存文件的头信息。 自动测试 使用curl发送请求 从请求中解析url，从url中获取服务路径号和url的路径 从服务路径中获取对应服务的缓存header文件，使用 strings 解析，使用grep搜索url的路径来判断url是否在缓存中。 性能测试大文件性能测试1234567891011121314151617181920212223242526272829303132333435363738 ab -n 100 -c 100 https://192.168.41.92:451/icons/123.pngServer Hostname: 192.168.41.92SSL/TLS Protocol: TLSv1/SSLv3,AES128-SHA,1024,128Document Path: /icons/123.pngDocument Length: 8675067 bytes (8.27M)Concurrency Level: 100Complete requests: 100Failed requests: 0Write errors: 0Total transferred: 867547978 bytesHTML transferred: 867506700 bytesServer Software: Apache/2.4.7Time taken for tests: 16.630 secondsRequests per second: 6.01 [#/sec] (mean)Time per request: 16630.198 [ms] (mean)Time per request: 166.302 [ms] (mean, across all concurrent requests)Transfer rate: 50943.94 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 29 3853 1878.0 4418 6428Processing: 1629 7901 3349.7 9461 11308Waiting: 13 992 1020.1 505 3371Total: 1658 11754 5163.3 13795 16620Server Software: SSL/5.x.xTime taken for tests: 11.467 secondsRequests per second: 8.72 [#/sec] (mean)Time per request: 11467.149 [ms] (mean)Time per request: 114.671 [ms] (mean, across all concurrent requests)Transfer rate: 73881.91 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 4 4435 3071.4 5345 8180Processing: 293 1948 1288.8 1616 4072Waiting: 0 18 18.2 11 87Total: 300 6383 4301.5 6982 11466 小文件性能测试1234567891011121314151617181920212223242526272829303132333435363738394041 ab -n 1500 -c 1500 https://192.168.41.92:452/Server Hostname: 192.168.41.92Server Port: 452SSL/TLS Protocol: TLSv1/SSLv3,AES128-SHA,1024,128Document Path: /Document Length: 12166 bytesConcurrency Level: 1500Complete requests: 1500Failed requests: 0Write errors: 0Total transferred: 18788981 bytesHTML transferred: 18249000 bytesServer Software: Apache/2.4.7Time taken for tests: 3.901 secondsRequests per second: 384.50 [#/sec] (mean)Time per request: 3901.171 [ms] (mean)Time per request: 2.601 [ms] (mean, across all concurrent requests)Transfer rate: 4703.36 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 84 367 412.0 314 3504Processing: 5 23 10.9 21 111Waiting: 4 21 10.4 18 101Total: 103 391 414.1 336 3544Server Software: SSL/5.x.xTime taken for tests: 3.234 secondsRequests per second: 463.88 [#/sec] (mean)Time per request: 3233.575 [ms] (mean)Time per request: 2.156 [ms] (mean, across all concurrent requests)Transfer rate: 5707.93 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 83 261 31.1 267 340Processing: 1 14 7.3 13 55Waiting: 0 12 7.0 11 53Total: 90 275 31.5 281 344 测试分析 使用cache的时候性能比没有使用时提高20%-30%性能。 文件越多，性能越高。 因为ab测试时是单文件测试，但是真实情况下多请求的时候性能是叠加的。 缓存满时的行为缓存文件大于内存盘的空间时的报错： error.log:10172:[Wed Jul 20 11:20:29 2016] [error] cache_disk: Error when writing cache file for URL 192.168.41.92/icons/123.png? 手动过期直接删除CacheRoot目录下生成的缓存文件 清理磁盘缓冲区htcacheclean 可以用于将mod_disk_cache的磁盘缓冲区占用的空间保持在一个合理的水平。在SSL5.2.4中没用编译这个工具，需要增加 2.4的mod_cache配置过滤 url 指令12345678910CacheQuickHandler off&lt;LocationMatch &quot;.*(jpg|gif)&quot;&gt; CacheEnable disk&lt;/LocationMatch&gt;CacheRoot /tmp/apacheCacheCacheDirLevels 3CacheDirLength 4CacheMaxFileSize 1048576CacheMinFileSize 10 在LocationMatch 的容器中加入 CacheEnable 的指令，将2.0作用域是RSRC_CONF变为RSRC_CONF|OR_AUTHCFG。 CacheQuickHandler off 将快速处理的挂钩关闭， 将处理阶段延后到handler业务处理阶段 这个指令将原来的 ap_run_quick_handler 转到 ap_run_handler 阶段, 因为 ap_location_walk 阶段在 ap_run_quick_handler 阶段之后，对url的处理也是在ap_run_quick_handler 之后的。 过滤器的处理apache 2.0 mod_cache 实现url过滤功能原mod_cache配置 CacheEnable disk / 其中 ／ 表示 url-string，在代码中这个url-string只在ap_cache_get_providers的函数中对providers进行了判断， if ((ent[i].url) &amp;&amp; !strncasecmp(url, ent[i].url, ent[i].urllen)) 其中 url 表示 r-&gt;parsed_uri.path， ent[i].url 表示 url-string。通过这个判断来选择providers。 实现url过滤 所有如果需要在 apache 2.0 mod_cache 实现url过滤功能，只需要改造这个条件语句，将这个条件变成正则表达式的判断。在 apache2.0 提供了 c 接口啊正则表达式接口。也可以使用 httpd.h 中的ap_pregcomp等接口实现。配置变成 1234567CacheEnable disk .*(jpg|gif)CacheDefaultExpire 3600CacheRoot /kssl/HRP/cfg/5/cache/ramdiskCacheDirLevels 3 CacheDirLength 4CacheMaxFileSize 10485760000CacheMinFileSize 10 不需要使用Location的容器“.*(jpg|gif)”正则匹配 gif和jpg的图片。 浏览器对cache的返回码缓存文件不超时的时候，无论是刷新还是强制刷新页面，缓存文件不被修改。（直接使用缓存文件，没有走到后面的更新缓存的钩子）缓存文件超时之后，刷新IE浏览器的页面，页面返回 304 的返回码，缓存文件不更新强制刷新之后，页面返回 200 的返回码，缓存文件更新。 CacheDefaultExpire 指令指定缓存文档的默认时间（以秒为单位），如果文档中没有提供过期日期和上次修改日期。由CacheMaxExpire指令指定的值不会覆盖此设置。 CacheMaxExpire 指令指定在不检查源服务器的情况下保留可缓存HTTP文档的最大秒数。因此，文档将最多过期这个秒数。即使文档提供了到期日，也会强制执行此最大值。 参考缓冲指南","tags":[{"name":"Tech, Apache","slug":"Tech-Apache","permalink":"https://trree.github.io/tags/Tech-Apache/"}]},{"title":"薛定谔的猫","date":"2016-10-16T02:22:29.000Z","path":"2016/10/16/Schrodinger-s-cat/","text":"量子力学中，有一只神奇的猫，是薛定谔的猫。在一个盒子里有一只猫，以及少量放射性物质。在一小时内，大约有50%的概率放射性物质将会衰变并释放出毒气杀死这只猫，剩50%的概率是放射性物质不会衰变而猫将活下来。我们这个世界时间是一维的，所以我们只能看到一维的结果，可是它存在两种可能，而且两种可能发生的概率是一样的。一维的时间我们只能看到一种可能，但不能因为我们看不到另外一种可能而否定它的存在，它就存在在那里。只是你无法感受。世界是无数个平行世界叠加统计的结果，如果将这个世界分散出去，在同一个结果中蕴含了无数中可能。平行世界的我现在一定还在419办公室，手里看着最新下载的论文，琢磨着作者想要表达什么，他在什么地方创新了，我从他这里又学到了什么，得到什么新的想法。平行世界的我一定还在计算我们到底有多少个平行世界？我该怎么用 ergodic hypothesis 证明平行世界，怎样将系综理论与平行世界联系起来考虑呢？平行世界的我一定看不到现在我，他怎么会去想呢？他也一定想不到。他只关心如何用热力学与统计物理的角度去证明平行世界，又怎么会在乎其他事情呢？超越时间的存在。我将所有的我重叠在同一时刻，他们是一条确定的轨迹。他们是如此的熟悉。可是如果将平行世界加入，这个世界就变得如此的庞杂。那一个平行世界的我是如此的陌生，我们之间也是如此的陌生。 在某一刻，我仿佛回到了过去，无数个我坐在我的旁边，我看着他们，他们都很冷淡的看着我。他们不明白我心里的热切。我又走到平行世界的我那里，那里的我是如此的截然不同。他们拥有不同的人生，截然不同的轨迹。 在那一刻，觉得世界美好有趣极了，我可以跟平行世界的我谈话，跟不同成长时段的我谈话，听我讲故事，听他们讲我遗忘的事情，讲我从未经历但确实经历过的事情。","tags":[{"name":"Caprice","slug":"Caprice","permalink":"https://trree.github.io/tags/Caprice/"}]},{"title":"工具","date":"2016-10-16T02:18:19.000Z","path":"2016/10/16/Tools/","text":"都说好的工具是成功的一半，并且好的工具对提升效率有非常大的帮助，所以在这里推荐一啊下好玩的工具。 windows软件 zeal(Mac dash) API 查看工具 typrora makrdown所见即所得工具 launch 快速启动工具 everything 快速文档搜索工具 bash on-my-zsh 在线工具 processon workflowy google analyze baidu analyze google drive blog hexo 翻墙 XX-Net","tags":[{"name":"Tech","slug":"Tech","permalink":"https://trree.github.io/tags/Tech/"}]},{"title":"Hello World","date":"2016-10-16T01:54:47.000Z","path":"2016/10/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]